// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type Audiences struct {
	Data  []*Audience `json:"data,omitempty"`
	Count int         `json:"count"`
}

type Campaigns struct {
	Count int         `json:"count"`
	Data  []*Campaign `json:"data,omitempty"`
}

type Comment struct {
	ID string `json:"id"`
}

func (Comment) IsEntity() {}

type Links struct {
	Data  []*Link `json:"data,omitempty"`
	Count int     `json:"count"`
}

type NewAudience struct {
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Segment     *SegmentInput          `json:"segment"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

type NewCampaign struct {
	Audience string                 `json:"audience"`
	Slug     string                 `json:"slug"`
	Type     CampaignType           `json:"type"`
	Name     string                 `json:"name"`
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

type NewLink struct {
	Domain   string                 `json:"domain"`
	Code     string                 `json:"code"`
	URL      string                 `json:"url"`
	Title    *string                `json:"title,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	Status   *string                `json:"status,omitempty"`
}

type RuleInput struct {
	Field    string `json:"field"`
	Operator string `json:"operator"`
	Value    string `json:"value"`
}

type Schedule struct {
	ID        string                 `json:"id"`
	Campaign  string                 `json:"campaign"`
	Start     string                 `json:"start"`
	End       string                 `json:"end"`
	Recurring bool                   `json:"recurring"`
	Frequency *string                `json:"frequency,omitempty"`
	Interval  *int                   `json:"interval,omitempty"`
	Days      []*string              `json:"days,omitempty"`
	Time      string                 `json:"time"`
	Timezone  string                 `json:"timezone"`
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
	Created   string                 `json:"created"`
	Updated   string                 `json:"updated"`
}

type Segment struct {
	ID          string             `json:"id"`
	Name        string             `json:"name"`
	Description *string            `json:"description,omitempty"`
	Criteria    []*SegmentCriteria `json:"criteria"`
	Created     string             `json:"created"`
	Updated     string             `json:"updated"`
	CreatedBy   *string            `json:"createdBy,omitempty"`
	UpdatedBy   *string            `json:"updatedBy,omitempty"`
}

type SegmentCriteria struct {
	Field    string          `json:"field"`
	Operator SegmentOperator `json:"operator"`
	Value    string          `json:"value"`
}

type SegmentInput struct {
	ID          *string      `json:"id,omitempty"`
	Name        string       `json:"name"`
	Description *string      `json:"description,omitempty"`
	Type        string       `json:"type"`
	Rules       []*RuleInput `json:"rules,omitempty"`
}

type Segments struct {
	Count int        `json:"count"`
	Data  []*Segment `json:"data,omitempty"`
}

type UpdateAudience struct {
	Name        *string                `json:"name,omitempty"`
	Description *string                `json:"description,omitempty"`
	Segment     *SegmentInput          `json:"segment,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

type UpdateCampaign struct {
	Audience *string                `json:"audience,omitempty"`
	Slug     *string                `json:"slug,omitempty"`
	Type     *CampaignType          `json:"type,omitempty"`
	Name     *string                `json:"name,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

type UpdateLink struct {
	Domain      *string                `json:"domain,omitempty"`
	Code        *string                `json:"code,omitempty"`
	URL         *string                `json:"url,omitempty"`
	Title       *string                `json:"title,omitempty"`
	Destination *string                `json:"destination,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
	Status      *string                `json:"status,omitempty"`
}

type CampaignStatus string

const (
	CampaignStatusDraft      CampaignStatus = "DRAFT"
	CampaignStatusScheduled  CampaignStatus = "SCHEDULED"
	CampaignStatusInProgress CampaignStatus = "IN_PROGRESS"
	CampaignStatusCompleted  CampaignStatus = "COMPLETED"
)

var AllCampaignStatus = []CampaignStatus{
	CampaignStatusDraft,
	CampaignStatusScheduled,
	CampaignStatusInProgress,
	CampaignStatusCompleted,
}

func (e CampaignStatus) IsValid() bool {
	switch e {
	case CampaignStatusDraft, CampaignStatusScheduled, CampaignStatusInProgress, CampaignStatusCompleted:
		return true
	}
	return false
}

func (e CampaignStatus) String() string {
	return string(e)
}

func (e *CampaignStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CampaignStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CampaignStatus", str)
	}
	return nil
}

func (e CampaignStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CampaignType string

const (
	CampaignTypeEmail            CampaignType = "EMAIL"
	CampaignTypeSms              CampaignType = "SMS"
	CampaignTypePushNotification CampaignType = "PUSH_NOTIFICATION"
)

var AllCampaignType = []CampaignType{
	CampaignTypeEmail,
	CampaignTypeSms,
	CampaignTypePushNotification,
}

func (e CampaignType) IsValid() bool {
	switch e {
	case CampaignTypeEmail, CampaignTypeSms, CampaignTypePushNotification:
		return true
	}
	return false
}

func (e CampaignType) String() string {
	return string(e)
}

func (e *CampaignType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CampaignType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CampaignType", str)
	}
	return nil
}

func (e CampaignType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SegmentOperator string

const (
	SegmentOperatorEquals      SegmentOperator = "EQUALS"
	SegmentOperatorNotEquals   SegmentOperator = "NOT_EQUALS"
	SegmentOperatorContains    SegmentOperator = "CONTAINS"
	SegmentOperatorNotContains SegmentOperator = "NOT_CONTAINS"
	SegmentOperatorGreaterThan SegmentOperator = "GREATER_THAN"
	SegmentOperatorLessThan    SegmentOperator = "LESS_THAN"
)

var AllSegmentOperator = []SegmentOperator{
	SegmentOperatorEquals,
	SegmentOperatorNotEquals,
	SegmentOperatorContains,
	SegmentOperatorNotContains,
	SegmentOperatorGreaterThan,
	SegmentOperatorLessThan,
}

func (e SegmentOperator) IsValid() bool {
	switch e {
	case SegmentOperatorEquals, SegmentOperatorNotEquals, SegmentOperatorContains, SegmentOperatorNotContains, SegmentOperatorGreaterThan, SegmentOperatorLessThan:
		return true
	}
	return false
}

func (e SegmentOperator) String() string {
	return string(e)
}

func (e *SegmentOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SegmentOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SegmentOperator", str)
	}
	return nil
}

func (e SegmentOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
