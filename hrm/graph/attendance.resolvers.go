package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/dailytravel/x/hrm/graph/model"
	"github.com/dailytravel/x/hrm/internal/utils"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// ID is the resolver for the id field.
func (r *attendanceResolver) ID(ctx context.Context, obj *model.Attendance) (string, error) {
	return obj.ID.Hex(), nil
}

// Date is the resolver for the date field.
func (r *attendanceResolver) Date(ctx context.Context, obj *model.Attendance) (string, error) {
	panic(fmt.Errorf("not implemented: Date - date"))
}

// TimeIn is the resolver for the time_in field.
func (r *attendanceResolver) TimeIn(ctx context.Context, obj *model.Attendance) (string, error) {
	return time.Unix(int64(obj.TimeIn.T), 0).Format(time.RFC3339), nil
}

// TimeOut is the resolver for the time_out field.
func (r *attendanceResolver) TimeOut(ctx context.Context, obj *model.Attendance) (*string, error) {
	if obj.TimeOut == nil {
		return nil, nil
	}

	timeOut := time.Unix(int64(obj.TimeOut.T), 0).Format(time.RFC3339)
	return &timeOut, nil
}

// Metadata is the resolver for the metadata field.
func (r *attendanceResolver) Metadata(ctx context.Context, obj *model.Attendance) (map[string]interface{}, error) {
	return obj.Metadata, nil
}

// Created is the resolver for the created field.
func (r *attendanceResolver) Created(ctx context.Context, obj *model.Attendance) (string, error) {
	return time.Unix(int64(obj.Created.T), 0).Format(time.RFC3339), nil
}

// Updated is the resolver for the updated field.
func (r *attendanceResolver) Updated(ctx context.Context, obj *model.Attendance) (string, error) {
	return time.Unix(int64(obj.Updated.T), 0).Format(time.RFC3339), nil
}

// UID is the resolver for the uid field.
func (r *attendanceResolver) UID(ctx context.Context, obj *model.Attendance) (string, error) {
	return obj.UID.Hex(), nil
}

// CheckIn is the resolver for the checkIn field.
func (r *mutationResolver) CheckIn(ctx context.Context) (*model.Attendance, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	filter := bson.M{
		"uid": uid,
		"time_in": bson.M{
			"$gte": primitive.Timestamp{T: uint32(time.Now().Unix()) - 86400},
			"$lt":  primitive.Timestamp{T: uint32(time.Now().Unix())},
		},
		"time_out": bson.M{
			"$exists": false,
		},
	}

	var item *model.Attendance
	err = r.db.Collection(item.Collection()).FindOne(ctx, filter, options.FindOne().SetSort(bson.D{{Key: "time_in", Value: -1}})).Decode(&item)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			in := primitive.Timestamp{T: uint32(time.Now().Unix())}
			item = &model.Attendance{
				UID:    *uid,
				TimeIn: &in,
			}

			res, err := r.db.Collection(item.Collection()).InsertOne(ctx, item, nil)
			if err != nil {
				return nil, err
			}

			item.ID = res.InsertedID.(primitive.ObjectID)

			return item, nil
		}

		return nil, err
	}

	return item, nil
}

// CheckOut is the resolver for the checkOut field.
func (r *mutationResolver) CheckOut(ctx context.Context) (*model.Attendance, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	filter := bson.M{
		"uid": uid,
		"time_in": bson.M{
			"$gte": primitive.Timestamp{T: uint32(time.Now().Unix()) - 86400},
			"$lt":  primitive.Timestamp{T: uint32(time.Now().Unix())},
		},
	}

	var item *model.Attendance // Initialize an instance of the Attendance model

	err = r.db.Collection(item.Collection()).FindOne(ctx, filter, options.FindOne().SetSort(bson.D{{Key: "time_in", Value: -1}})).Decode(&item)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("attendance not found")
		}
		return nil, err
	}

	out := primitive.Timestamp{T: uint32(time.Now().Unix())}
	item.TimeOut = &out

	_, err = r.db.Collection(item.Collection()).UpdateOne(ctx, bson.M{"_id": item.ID}, bson.M{"$set": item}, nil)
	if err != nil {
		return nil, err
	}

	return item, nil // Return a pointer to the updated item
}

// CreateAttendance is the resolver for the createAttendance field.
func (r *mutationResolver) CreateAttendance(ctx context.Context, input model.NewAttendance) (*model.Attendance, error) {
	// Create a new attendance
	item := &model.Attendance{
		Status: *input.Status,
		Model: model.Model{
			Metadata: input.Metadata,
		},
	}

	// Perform the insertion into the database
	_, err := r.db.Collection("attendances").InsertOne(ctx, item)
	if err != nil {
		return nil, err
	}

	return item, nil
}

// UpdateAttendance is the resolver for the updateAttendance field.
func (r *mutationResolver) UpdateAttendance(ctx context.Context, id string, input model.UpdateAttendance) (*model.Attendance, error) {
	// Convert the ID string to ObjectID
	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	// Find the item by ID
	item := &model.Attendance{}
	filter := bson.M{"_id": _id}
	err = r.db.Collection(item.Collection()).FindOne(ctx, filter).Decode(item)
	if err != nil {
		return nil, err
	}

	// Update fields if provided in input
	if input.Status != nil {
		item.Status = *input.Status
	}
	if input.Notes != nil {
		item.Notes = *input.Notes
	}

	// Update the attendance record in the database
	update := bson.M{
		"$set": bson.M{
			"status": item.Status,
			"notes":  item.Notes,
		},
	}
	opts := options.FindOneAndUpdate().SetReturnDocument(options.After)

	var updated model.Attendance
	err = r.db.Collection("attendances").FindOneAndUpdate(ctx, filter, update, opts).Decode(&updated)
	if err != nil {
		return nil, err
	}

	return &updated, nil
}

// DeleteAttendance is the resolver for the deleteAttendance field.
func (r *mutationResolver) DeleteAttendance(ctx context.Context, id string) (map[string]interface{}, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	// Convert the ID string to an ObjectID
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	// Create a filter to match the provided ID
	filter := bson.M{"_id": objectID}

	// Update the attendance record to mark it as deleted
	archiveFields := bson.M{
		"status":     "archived",
		"updated_by": uid,
		"deleted_at": primitive.Timestamp{T: uint32(time.Now().Unix())},
	}

	update := bson.M{"$set": archiveFields}
	updateResult, err := r.db.Collection("attendances").UpdateOne(ctx, filter, update)
	if err != nil {
		return nil, err
	}

	if updateResult.MatchedCount == 0 {
		return nil, fmt.Errorf("attendance not found")
	}

	return map[string]interface{}{
		"success": true,
	}, nil
}

// DeleteAttendances is the resolver for the deleteAttendances field.
func (r *mutationResolver) DeleteAttendances(ctx context.Context, ids []string) (map[string]interface{}, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	// Convert string IDs to ObjectIDs
	objectIDs := make([]primitive.ObjectID, len(ids))
	for i, id := range ids {
		objectID, err := primitive.ObjectIDFromHex(id)
		if err != nil {
			return nil, err
		}
		objectIDs[i] = objectID
	}

	// Create a filter to match the provided IDs
	filter := bson.M{"_id": bson.M{"$in": objectIDs}}

	// Update the attendance records to mark them as deleted
	archiveFields := bson.M{
		"status":     "archived",
		"updated_by": uid,
		"deleted_at": primitive.Timestamp{T: uint32(time.Now().Unix())},
	}

	update := bson.M{"$set": archiveFields}
	updateResult, err := r.db.Collection("attendances").UpdateMany(ctx, filter, update)
	if err != nil {
		return nil, err
	}

	return map[string]interface{}{
		"success":      true,
		"deletedCount": updateResult.ModifiedCount,
	}, nil
}

// Attendance is the resolver for the attendance field.
func (r *queryResolver) Attendance(ctx context.Context, id string) (*model.Attendance, error) {
	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	var item *model.Attendance
	filter := bson.M{"_id": _id}

	if err := r.db.Collection(item.Collection()).FindOne(ctx, filter).Decode(&item); err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, fmt.Errorf("no document found for filter %v", filter)
		}
		return nil, err
	}

	return item, nil
}

// Attendances is the resolver for the attendances field.
func (r *queryResolver) Attendances(ctx context.Context, stages map[string]interface{}) (*model.Attendances, error) {
	pipeline := bson.A{}

	// Add additional stages to the pipeline
	for key, value := range stages {
		stage := bson.D{{Key: key, Value: value}}
		pipeline = append(pipeline, stage)
	}

	cursor, err := r.db.Collection("attendances").Aggregate(ctx, pipeline)
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var items []*model.Attendance

	if err := cursor.All(ctx, &items); err != nil {
		return nil, err
	}

	return &model.Attendances{
		Count: int(cursor.RemainingBatchLength()),
		Data:  items,
	}, nil
}

// Attendance returns AttendanceResolver implementation.
func (r *Resolver) Attendance() AttendanceResolver { return &attendanceResolver{r} }

type attendanceResolver struct{ *Resolver }
