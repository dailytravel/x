type Contract {
  id: ID!
  user: User!
  contact: Contact!
  reference: String!
  description: String!
  amount: Float!
  currency: String!
  start_date: String!
  end_date: String!
  auto_renew: Boolean!
  metadata: Map
  status: String! #"draft" | "active" | "completed" | "canceled";
  created_at: String!
  updated_at: String!
  comments: [Comment]
  followers: [Follow]
}

type Contracts {
  data: [Contract]
  count: Int!
}

enum ContractStatus {
  DRAFT
  PENDING
  ACTIVE
  EXPIRED
  TERMINATED
}

input NewContract {
  user: ID!
  contact: ID!
  reference: String!
  description: String!
  amount: Float!
  currency: String!
  start_date: String!
  end_date: String!
  auto_renew: Boolean!
  categories: [ID!]
  metadata: Map
}

input UpdateContract {
  user: ID
  contact: ID
  reference: String
  description: String
  amount: Float
  currency: String
  start_date: String
  end_date: String
  auto_renew: Boolean
  categories: [ID!]
  metadata: Map
}

extend type Query {
  contract(id: ID!): Contract @auth
  contracts(args: Map): Contracts @auth
}

extend type Mutation {
  createContract(input: NewContract!): Contract @auth(requires: [ADMIN])
  updateContract(id: ID!, input: UpdateContract!): Contract
    @auth(requires: [ADMIN])
  deleteContract(id: ID!): Map @auth(requires: [ADMIN])
  deleteContracts(ids: [ID!]!): Map @auth(requires: [ADMIN])
}
