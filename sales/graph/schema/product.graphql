type Product @key(fields: "id") {
  id: ID!
  uid: ID!
  locale: String!
  type: String!
  slug: String!
  name: String!
  description: String!
  duration: Int! # in hours
  notes: String!
  tips: String!
  highlights: String!
  expectation: String!
  faqs: String!
  reviews: Int!
  rating: Float!
  booked: Int!
  reviewable: Boolean!
  price: Float!
  discount: Float!
  currency: String!
  metadata: Map
  status: String!
  created: String!
  updated: String!
  place: ID!
  terms: [ID]
  places: [ID]
}

enum ProductStatus {
  ACTIVE
  INACTIVE
  PENDING
  ARCHIVED
}

type Products {
  count: Int!
  data: [Product]
}

input NewProduct {
  uid: ID!
  locale: String!
  type: String!
  slug: String!
  name: String!
  description: String!
  duration: Int! # in hours
  notes: String!
  images: [Map!]!
  tips: String!
  highlights: String!
  expectation: String!
  faqs: String!
  reviews: Int!
  rating: Float!
  booked: Int!
  reviewable: Boolean!
  price: Float!
  discount: Float!
  currency: String!
  metadata: Map
  status: String!
  place: ID!
}

input UpdateProduct {
  uid: ID
  locale: String
  type: String
  slug: String
  name: String
  description: String
  duration: Int # in hours
  notes: String
  images: [Map!]
  tips: String
  highlights: String
  expectation: String
  faqs: String
  reviews: Int
  rating: Float
  booked: Int
  price: Float
  discount: Float
  currency: String
  reviewable: Boolean
  metadata: Map
  status: String
  place: ID
}

extend type Query {
  product(id: ID!): Product
  products(
    filter: Map
    project: Map
    sort: Map
    collation: Map
    limit: Int
    skip: Int
  ): Products
}

extend type Mutation {
  createProduct(input: NewProduct!): Product @auth
  updateProduct(id: ID!, input: UpdateProduct!): Product @auth
  deleteProduct(id: ID!): Boolean @auth
}
