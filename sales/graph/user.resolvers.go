package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"

	"github.com/dailytravel/x/sales/graph/model"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// Memberships is the resolver for the memberships field.
func (r *userResolver) Memberships(ctx context.Context, obj *model.User) ([]*model.Membership, error) {
	var items []*model.Membership

	uid, err := primitive.ObjectIDFromHex(obj.ID)
	if err != nil {
		return nil, err
	}

	filter := bson.M{"uid": uid}
	//find all items
	cur, err := r.db.Collection("memberships").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	for cur.Next(ctx) {
		var item *model.Membership
		if err := cur.Decode(&item); err != nil {
			return nil, err
		}
		items = append(items, item)
	}

	return items, nil
}

// Wishlists is the resolver for the wishlists field.
func (r *userResolver) Wishlists(ctx context.Context, obj *model.User) ([]*model.Wishlist, error) {
	var items []*model.Wishlist

	uid, err := primitive.ObjectIDFromHex(obj.ID)
	if err != nil {
		return nil, err
	}

	filter := bson.M{"uid": uid}
	//find all items
	cur, err := r.db.Collection("wishlists").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	for cur.Next(ctx) {
		var item *model.Wishlist
		if err := cur.Decode(&item); err != nil {
			return nil, err
		}
		items = append(items, item)
	}

	return items, nil
}

// Coupons is the resolver for the coupons field.
func (r *userResolver) Coupons(ctx context.Context, obj *model.User) ([]*model.Coupon, error) {
	var items []*model.Coupon

	uid, err := primitive.ObjectIDFromHex(obj.ID)
	if err != nil {
		return nil, err
	}

	filter := bson.M{"uid": uid}
	//find all items
	cur, err := r.db.Collection("coupons").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	for cur.Next(ctx) {
		var item *model.Coupon
		if err := cur.Decode(&item); err != nil {
			return nil, err
		}
		items = append(items, item)
	}

	return items, nil
}

// Companies is the resolver for the companies field.
func (r *userResolver) Companies(ctx context.Context, obj *model.User) ([]*model.Company, error) {
	var items []*model.Company

	uid, err := primitive.ObjectIDFromHex(obj.ID)
	if err != nil {
		return nil, err
	}

	filter := bson.M{"uid": uid}
	//find all items
	cur, err := r.db.Collection("companies").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	for cur.Next(ctx) {
		var item *model.Company
		if err := cur.Decode(&item); err != nil {
			return nil, err
		}
		items = append(items, item)
	}

	return items, nil
}

// Contacts is the resolver for the contacts field.
func (r *userResolver) Contacts(ctx context.Context, obj *model.User) ([]*model.Contact, error) {
	var items []*model.Contact

	uid, err := primitive.ObjectIDFromHex(obj.ID)
	if err != nil {
		return nil, err
	}

	filter := bson.M{"uid": uid}
	//find all items
	cur, err := r.db.Collection("contacts").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	for cur.Next(ctx) {
		var item *model.Contact
		if err := cur.Decode(&item); err != nil {
			return nil, err
		}
		items = append(items, item)
	}

	return items, nil
}

// Quotes is the resolver for the quotes field.
func (r *userResolver) Quotes(ctx context.Context, obj *model.User) ([]*model.Quote, error) {
	var items []*model.Quote

	uid, err := primitive.ObjectIDFromHex(obj.ID)
	if err != nil {
		return nil, err
	}

	filter := bson.M{"uid": uid}
	//find all items
	cur, err := r.db.Collection("quotes").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	for cur.Next(ctx) {
		var item *model.Quote
		if err := cur.Decode(&item); err != nil {
			return nil, err
		}
		items = append(items, item)
	}

	return items, nil
}

// Orders is the resolver for the orders field.
func (r *userResolver) Orders(ctx context.Context, obj *model.User) ([]*model.Order, error) {
	var items []*model.Order

	uid, err := primitive.ObjectIDFromHex(obj.ID)
	if err != nil {
		return nil, err
	}

	filter := bson.M{"uid": uid}
	//find all items
	cur, err := r.db.Collection("orders").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	for cur.Next(ctx) {
		var item *model.Order
		if err := cur.Decode(&item); err != nil {
			return nil, err
		}
		items = append(items, item)
	}

	return items, nil
}

// Credits is the resolver for the credits field.
func (r *userResolver) Credits(ctx context.Context, obj *model.User) (*int, error) {
	panic(fmt.Errorf("not implemented: Credits - credits"))
}

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }
