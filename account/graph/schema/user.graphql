type User @key(fields: "id") {
  id: ID!
  name: String!
  given_name: String
  family_name: String
  email: String!
  phone: String
  roles: [String]
  mfa: MFA
  timezone: String
  locale: String
  picture: String
  last_login: String
  email_verified: Boolean
  phone_verified: Boolean
  metadata: Map
  status: String
  created: String!
  updated: String!
  identities: [Identity]
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING
}

enum SocialProvider {
  FACEBOOK
  GOOGLE
  TWITTER
  GITHUB
}

type Users {
  count: Int!
  data: [User]
}

type MFA {
  enabled: Boolean!
  code: String!
}

type Payload {
  access_token: String!
  expires_in: Int!
  refresh_token: String!
  token_type: String!
  user: User!
}

# Input Types
input MFAInput {
  enabled: Boolean!
  code: String!
}

input NewUser {
  name: String!
  given_name: String
  family_name: String
  email: String!
  phone: String
  password: String!
  roles: [String]
  timezone: String
  locale: String
  picture: String
  status: String
}

input UpdateUser {
  name: String
  given_name: String
  family_name: String
  password: String
  roles: [String]
  timezone: String
  locale: String
  picture: String
  status: String
  metadata: Map
}

input LoginInput {
  # User credentials
  username: String!
  password: String!

  # OAuth 2.0 authentication parameters
  grant_type: String
  scope: String

  # Client credentials (for OAuth 2.0 client authentication)
  client_id: String
  client_secret: String
}

input SocialLoginInput {
  # User credentials
  username: String!
  password: String!

  # OAuth 2.0 authentication parameters
  grant_type: String
  scope: String

  # Client credentials (for OAuth 2.0 client authentication)
  client_id: String
  client_secret: String

  # Social provider
  provider: String!
  token: String!
}

input RegisterInput {
  name: String!
  email: String!
  password: String!
  password_confirmation: String!
}

input UpdatePassword {
  old_password: String!
  password: String!
  password_confirmation: String!
}

input ResetPasswordInput {
  token: String!
  password: String!
  password_confirmation: String!
}

type AuthPayload {
  access_token: String
  refresh_token: String
  expires_in: Int
  token_type: String
  user: User
}

type RefreshTokenPayload {
  access_token: String!
  refresh_token: String!
  expires_in: Int!
  token_type: String!
}

extend type Query {
  users(args: Map): Map @auth(roles: [ADMIN]) #for search users on typesense
  user(id: ID!): User @auth(roles: [ADMIN])
  owners(ids: [String!]!, limit: Int, offset: Int): Users @auth
  me: User @auth
}

extend type Mutation {
  createUser(input: NewUser!): User @auth(roles: [ADMIN])
  updateUser(id: ID!, input: UpdateUser!): User
  register(input: RegisterInput!): User
  verifyEmail(token: String!): Map
  verifyPhone(token: String!): Map
  login(input: LoginInput!): AuthPayload
  socialLogin(input: SocialLoginInput!): AuthPayload
  refreshToken(refresh_token: String!): RefreshTokenPayload
  forgotPassword(email: String!): Map
  resetPassword(input: ResetPasswordInput!): Map
  UpdatePassword(input: UpdatePassword!): Map @auth
  deactivate: User @auth
  deleteUser(id: ID!): Boolean
  deleteUsers(ids: [ID!]!): Boolean
}
