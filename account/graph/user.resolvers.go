package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/dailytravel/x/account/graph/model"
	"github.com/dailytravel/x/account/internal/utils"
	"github.com/dailytravel/x/account/pkg/auth"
	"github.com/go-redis/redis"
	jwt "github.com/golang-jwt/jwt/v4"
	"github.com/google/uuid"
	"github.com/typesense/typesense-go/typesense/api/pointer"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"golang.org/x/crypto/bcrypt"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	panic(fmt.Errorf("not implemented: CreateUser - createUser"))
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUser) (*model.User, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	filter := bson.M{"_id": _id}

	item := &model.User{
		Name:     *input.Name,
		Timezone: input.Timezone,
		Locale:   input.Locale,
		Picture:  input.Picture,
		Status:   input.Status,
		Model: model.Model{
			UpdatedBy: uid,
		},
	}

	for _, role := range input.Roles {
		item.Roles = append(item.Roles, *role)
	}

	if err := r.db.Collection(item.Collection()).FindOneAndUpdate(ctx, filter, bson.M{"$set": item}).Decode(item); err != nil {
		return nil, err
	}

	return item, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.NewUser) (*model.User, error) {
	// 1. Validate the input (you might have more validation rules)
	if input.Email == "" || input.Password == "" || input.Name == "" {
		return nil, fmt.Errorf("email, password and name are required")
	}

	// 2. Check if a user with the same email already exists
	var existingUser model.User
	err := r.db.Collection("users").FindOne(ctx, bson.M{"email": input.Email}).Decode(&existingUser)
	if err != nil && err != mongo.ErrNoDocuments {
		return nil, fmt.Errorf("error checking for existing user: %v", err)
	}

	// 3. Hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %v", err)
	}

	// 4. Create the user
	newUser := &model.User{
		Name:     input.Name,
		Email:    input.Email,
		Password: string(hashedPassword),
		// Add other fields from input if they exist
	}
	_, err = r.db.Collection("users").InsertOne(ctx, newUser)
	if err != nil {
		return nil, fmt.Errorf("failed to insert user: %v", err)
	}

	// 5. Return the created user (excluding the hashed password for security reasons)
	newUser.Password = ""
	return newUser, nil
}

// VerifyEmail is the resolver for the verifyEmail field.
func (r *mutationResolver) VerifyEmail(ctx context.Context, token string) (map[string]interface{}, error) {
	// Retrieve the user's email or ID from the token. This could be stored in Redis or another cache.
	id, err := r.redis.Get(ctx, token).Result() // using Redis as an example
	if err == redis.Nil {
		return nil, fmt.Errorf("invalid or expired token")
	} else if err != nil {
		return nil, fmt.Errorf("failed to retrieve token data: %s", err.Error())
	}

	// Convert the string ID to MongoDB's ObjectID format
	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user id: %s", err.Error())
	}

	// Define a filter to fetch the user by their email or ID.
	// Depending on what's stored in the token, adjust the filter accordingly.
	filter := bson.M{"_id": _id} // assuming the token stored the email, adjust if it's an ID or something else

	// Find the user and ensure they exist
	var user *model.User
	err = r.db.Collection("users").FindOne(ctx, filter).Decode(&user)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("error fetching user: %s", err.Error())
	}

	// Check if the user's email is already verified
	if *user.EmailVerified {
		return nil, fmt.Errorf("email is already verified")
	}

	// Update the user's EmailVerified status
	update := bson.M{"$set": bson.M{"emailVerified": true}}
	_, err = r.db.Collection("users").UpdateOne(ctx, filter, update)
	if err != nil {
		return nil, fmt.Errorf("error updating email verification status: %s", err.Error())
	}

	// Optionally, remove the token so it can't be used again
	_, err = r.redis.Del(ctx, token).Result()
	if err != nil {
		// This isn't a critical error, but you may want to log it for audit purposes.
		fmt.Printf("Warning: failed to delete token from cache: %s\n", err.Error())
	}

	// Return a success message
	return map[string]interface{}{
		"message": "Email successfully verified.",
		"email":   user.Email,
	}, nil
}

// VerifyPhone is the resolver for the verifyPhone field.
func (r *mutationResolver) VerifyPhone(ctx context.Context, token string) (map[string]interface{}, error) {
	// Retrieve the user's phone number or ID from the token. This could be stored in Redis or another cache.
	id, err := r.redis.Get(ctx, token).Result() // using Redis as an example
	if err == redis.Nil {
		return nil, fmt.Errorf("invalid or expired token")
	} else if err != nil {
		return nil, fmt.Errorf("failed to retrieve token data: %s", err.Error())
	}

	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user id: %s", err.Error())
	}

	// Define a filter to fetch the user by their phone number or ID.
	// Depending on what's stored in the token, adjust the filter accordingly.
	filter := bson.M{"_id": _id} // assuming the token stored the phone number, adjust if it's an ID or something else

	// Find the user and ensure they exist
	var user *model.User
	err = r.db.Collection(model.UserCollection).FindOne(ctx, filter).Decode(&user)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("error fetching user: %s", err.Error())
	}

	// Check if the user's phone is already verified
	if *user.PhoneVerified {
		return nil, fmt.Errorf("phone number is already verified")
	}

	// Update the user's PhoneVerified status
	update := bson.M{"$set": bson.M{"phoneVerified": true}}
	_, err = r.db.Collection(model.UserCollection).UpdateOne(ctx, filter, update)
	if err != nil {
		return nil, fmt.Errorf("error updating phone verification status: %s", err.Error())
	}

	// Optionally, remove the token so it can't be used again
	_, err = r.redis.Del(ctx, token).Result()
	if err != nil {
		// This isn't a critical error, but you may want to log it for audit purposes.
		fmt.Printf("Warning: failed to delete token from cache: %s\n", err.Error())
	}

	// Return a success message
	return map[string]interface{}{
		"message": "Phone number successfully verified.",
		"phone":   user.Phone,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.Payload, error) {
	var u *model.User
	var k *model.Key
	var a *model.Api
	var c *model.Client

	client := auth.APIKey(ctx)
	if client == nil {
		return nil, fmt.Errorf("client not found")
	}

	//check client
	if err := r.db.Collection("clients").FindOne(ctx, bson.M{"secret": client}, nil).Decode(&c); err != nil {
		return nil, fmt.Errorf("client not found")
	}

	//check api
	if err := r.db.Collection("apis").FindOne(ctx, bson.M{"identifier": "https://api.trip.express/graphql"}, nil).Decode(&a); err != nil {
		return nil, fmt.Errorf("api not found")
	}

	//find user by email
	if err := r.db.Collection(model.UserCollection).FindOne(ctx, bson.M{"email": email}, nil).Decode(&u); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	//check password
	if err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password)); err != nil {
		return nil, fmt.Errorf("password not match")
	}

	//get rsa key
	if err := r.db.Collection(model.KeyCollection).FindOne(ctx, bson.M{"status": "current"}, nil).Decode(&k); err != nil {
		return nil, fmt.Errorf("key not found")
	}

	//create token
	t := &model.Token{
		UID:       u.ID,
		Name:      "auth",
		Token:     uuid.NewString(),
		Abilities: []*string{pointer.String("*")},
		ExpiresAt: &primitive.Timestamp{T: uint32(time.Now().Add(time.Duration(time.Second * time.Duration(a.Expiration))).Unix())},
	}

	//insert token
	if _, err := r.db.Collection(t.Collection()).InsertOne(ctx, t); err != nil {
		return nil, err
	}

	access_token, err := auth.Token(jwt.MapClaims{
		"jti":      t.Token,
		"sub":      u.ID.Hex(),
		"email":    u.Email,
		"name":     u.Name,
		"locale":   u.Locale,
		"timezone": u.Timezone,
		"picture":  u.Picture,
		"roles":    strings.Join(u.Roles, " "),
		"scope":    "*",
		"aud":      a.Identifier,
		"iss":      strings.Join([]string{"https://", c.Domain}, ""),
		"azp":      c.ID.Hex(),
		"iat":      time.Now().Unix(),
		"exp":      t.ExpiresAt.T,
	}, *k)

	if err != nil {
		return nil, err
	}

	refresh_token, err := auth.Token(jwt.MapClaims{
		"jti": t.Token,
		"sub": u.ID.Hex(),
		"aud": a.Identifier,
		"iss": strings.Join([]string{"https://", c.Domain}, ""),
		"azp": c.ID.Hex(),
		"iat": time.Now().Unix(),
		"exp": time.Now().Add(time.Hour * 24 * 30).Unix(),
	}, *k)

	if err != nil {
		return nil, err
	}

	return &model.Payload{
		AccessToken:  *access_token,
		RefreshToken: *refresh_token,
		TokenType:    "Bearer",
		ExpiresIn:    3600,
	}, nil
}

// SocialLogin is the resolver for the socialLogin field.
func (r *mutationResolver) SocialLogin(ctx context.Context, provider model.SocialProvider, accessToken string) (*model.Payload, error) {
	var u *model.User
	var k *model.Key
	var a *model.Api
	var c *model.Client

	client := auth.APIKey(ctx)
	if client == nil {
		return nil, fmt.Errorf("client not found")
	}

	//check client
	if err := r.db.Collection("clients").FindOne(ctx, bson.M{"secret": client}, nil).Decode(&c); err != nil {
		return nil, fmt.Errorf("client not found")
	}
	// verify token from provider by google oauth
	email, err := auth.GoogleLogin(ctx, accessToken)
	if err != nil {
		return nil, err
	}

	// Check if the user already exists in the system
	if err := r.db.Collection("users").FindOne(ctx, bson.M{"email": email}, nil).Decode(&u); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	//get rsa key
	if err := r.db.Collection("keys").FindOne(ctx, bson.M{"status": "current"}, nil).Decode(&k); err != nil {
		return nil, fmt.Errorf("key not found")
	}

	access_token, err := auth.Token(jwt.MapClaims{
		"sub":   u.ID.Hex(),
		"roles": strings.Join(u.Roles, " "),
		"scope": "*",
		"aud":   a.Identifier,
		"iss":   strings.Join([]string{"https://", c.Domain}, ""),
		"azp":   c.ID.Hex(),
		"iat":   time.Now().Unix(),
		"exp":   time.Now().Add(time.Duration(time.Second * time.Duration(a.Expiration))).Unix(),
	}, *k)

	if err != nil {
		return nil, err
	}

	refresh_token, err := auth.Token(jwt.MapClaims{
		"sub": u.ID.Hex(),
		"aud": a.Identifier,
		"iss": strings.Join([]string{"https://", c.Domain}, ""),
		"azp": c.ID.Hex(),
		"iat": time.Now().Unix(),
		"exp": time.Now().Add(time.Hour * 24 * 30).Unix(),
	}, *k)

	if err != nil {
		return nil, err
	}

	return &model.Payload{
		AccessToken:  *access_token,
		RefreshToken: *refresh_token,
		TokenType:    "Bearer",
		ExpiresIn:    3600,
	}, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, email string) (map[string]interface{}, error) {
	// Find user by email
	var user model.User
	if err := r.db.Collection(model.UserCollection).FindOne(ctx, bson.M{"email": email}).Decode(&user); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to retrieve user: %s", err.Error())
	}

	// Generate a unique code for the user
	token := uuid.New().String()

	// Store the code in Redis for 24 hours
	if err := r.redis.Set(ctx, token, user.ID.Hex(), time.Hour*24).Err(); err != nil {
		return nil, fmt.Errorf("failed to store code: %s", err.Error())
	}

	// Return a response
	response := map[string]interface{}{
		"message": "A password reset email has been sent.",
	}
	return response, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, token string, password string) (map[string]interface{}, error) {
	// Retrieve userId from Redis
	userId, err := r.redis.Get(ctx, token).Result()
	if err != nil {
		if err == redis.Nil {
			return nil, fmt.Errorf("invalid token")
		}
		return nil, fmt.Errorf("failed to retrieve token from Redis: %v", err)
	}

	// Convert userID to ObjectID
	id, err := primitive.ObjectIDFromHex(userId)
	if err != nil {
		return nil, fmt.Errorf("invalid user id: %v", err)
	}

	// Retrieve user by ID
	var user *model.User
	if err := r.db.Collection(model.UserCollection).FindOne(ctx, bson.M{"_id": id}).Decode(&user); err != nil {
		return nil, fmt.Errorf("failed to retrieve user: %v", err)
	}

	// Hash the new password
	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %v", err)
	}

	// Check if the new password is the same as the old password
	cursor, err := r.db.Collection("passwords").Find(ctx, bson.M{"uid": user.ID})
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve old passwords: %v", err)
	}
	defer cursor.Close(ctx)

	var oldPasswords []*model.Password
	if err = cursor.All(ctx, &oldPasswords); err != nil {
		return nil, fmt.Errorf("failed to decode old passwords: %v", err)
	}

	for _, oldPwd := range oldPasswords {
		if err := bcrypt.CompareHashAndPassword([]byte(oldPwd.Hash), []byte(password)); err == nil {
			return nil, fmt.Errorf("new password cannot be the same as the old password")
		}
	}

	// Create a new password struct
	pwd := &model.Password{
		UID:  user.ID,
		Hash: user.Password,
	}

	// Update the user's password in the database
	result, err := r.db.Collection(model.UserCollection).UpdateOne(ctx, bson.M{"_id": user.ID}, bson.M{"$set": bson.M{"password": hash}})
	if err != nil || result.ModifiedCount == 0 {
		return nil, fmt.Errorf("failed to update user password: %v", err)
	}

	// Add the old password to the user's password history
	if _, err := r.db.Collection("passwords").InsertOne(ctx, pwd); err != nil {
		return nil, fmt.Errorf("failed to insert old password: %v", err)
	}

	// Delete the token from Redis
	if _, err := r.redis.Del(ctx, token).Result(); err != nil {
		return nil, fmt.Errorf("failed to delete token from Redis: %v", err)
	}

	return map[string]interface{}{
		"message": "Password updated successfully.",
		"email":   user.Email,
	}, nil
}

// Deactivate is the resolver for the deactivate field.
func (r *mutationResolver) Deactivate(ctx context.Context) (*model.User, error) {
	// Retrieve the user ID from context
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	// Find the user by ID and ensure they exist
	filter := bson.M{"_id": uid}
	var user *model.User
	err = r.db.Collection(model.UserCollection).FindOne(ctx, filter).Decode(&user)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("error fetching user: %s", err.Error())
	}

	// Check if the user is already deactivated
	if user.Status == pointer.String("DEACTIVATED") {
		return nil, fmt.Errorf("user is already deactivated")
	}

	// Update user status to deactivated
	update := bson.M{"$set": bson.M{"status": "DEACTIVATED"}}
	_, err = r.db.Collection(model.UserCollection).UpdateOne(ctx, filter, update)
	if err != nil {
		return nil, fmt.Errorf("error deactivating user: %s", err.Error())
	}

	// Return the updated user (you may choose to fetch the latest state from DB if required)
	user.Status = pointer.String("DEACTIVATED")
	return user, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*bool, error) {
	// Convert the string ID to MongoDB's ObjectID format
	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	// Delete the user from the database
	res, err := r.db.Collection("users").DeleteOne(ctx, bson.M{"_id": _id})
	if err != nil {
		return nil, err
	}

	// Check if any document was deleted
	if res.DeletedCount == 0 {
		return nil, nil
	}

	return pointer.True(), nil
}

// DeleteUsers is the resolver for the deleteUsers field.
func (r *mutationResolver) DeleteUsers(ctx context.Context, ids []string) (*bool, error) {
	// Convert string IDs to ObjectIDs
	objectIDs := make([]primitive.ObjectID, len(ids))
	for i, id := range ids {
		oid, err := primitive.ObjectIDFromHex(id)
		if err != nil {
			return nil, fmt.Errorf("invalid ID format: %s", id)
		}
		objectIDs[i] = oid
	}

	// Create filter to delete multiple users based on their ObjectIDs
	filter := bson.M{"_id": bson.M{"$in": objectIDs}}

	// Delete users from the database
	result, err := r.db.Collection(model.UserCollection).DeleteMany(ctx, filter)
	if err != nil {
		return nil, fmt.Errorf("error deleting users: %s", err.Error())
	}

	// If no users were deleted, return false
	if result.DeletedCount == 0 {
		return nil, fmt.Errorf("no users found to delete")
	}

	// Return true if successful
	return pointer.True(), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, args map[string]interface{}) (map[string]interface{}, error) {
	res, err := r.ts.Collection(model.UserCollection).Documents().Search(utils.Params(args))
	if err != nil {
		return nil, err
	}

	// Convert struct to map
	results, err := utils.StructToMap(res)
	if err != nil {
		return nil, err
	}

	return results, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	var item *model.User
	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	filter := bson.M{"_id": _id}
	options := options.FindOne().SetProjection(bson.M{"_id": 1, "name": 1, "email": 1, "photos": 1})

	if err := r.db.Collection(item.Collection()).FindOne(ctx, filter, options).Decode(&item); err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, fmt.Errorf("no document found for filter %v", filter)
		}
		return nil, err
	}

	return item, nil
}

// Owners is the resolver for the owners field.
func (r *queryResolver) Owners(ctx context.Context, ids []string, limit *int, offset *int) (*model.Users, error) {
	var users []*model.User

	// Convert string IDs to ObjectIDs
	objectIds := make([]primitive.ObjectID, 0, len(ids))
	for _, idStr := range ids {
		objectId, err := primitive.ObjectIDFromHex(idStr)
		if err != nil {
			return nil, fmt.Errorf("invalid _id format: %s", idStr)
		}
		objectIds = append(objectIds, objectId)
	}

	// Construct the query
	query := bson.M{"_id": bson.M{"$in": objectIds}}

	opts := options.Find()
	if limit != nil {
		opts.SetLimit(int64(*limit))
	}

	if offset != nil {
		opts.SetSkip(int64(*offset))
	}

	// Fetch the users based on the filter and pagination options
	cursor, err := r.db.Collection("users").Find(ctx, query, opts)
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	// Decode each found document into a user struct
	for cursor.Next(ctx) {
		var user model.User
		if err := cursor.Decode(&user); err != nil {
			return nil, err
		}
		users = append(users, &user)
	}

	// In case there's an error during the cursor iteration
	if err := cursor.Err(); err != nil {
		return nil, err
	}

	// Get the total count of users based on the filter
	count, err := r.db.Collection("users").CountDocuments(ctx, query)
	if err != nil {
		return nil, err
	}

	return &model.Users{
		Count: int(count),
		Data:  users,
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	var item *model.User
	//find user by id
	if err := r.db.Collection(model.UserCollection).FindOne(ctx, bson.M{"_id": uid}, nil).Decode(&item); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	return item, nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *model.User) (string, error) {
	return obj.ID.Hex(), nil
}

// LastLogin is the resolver for the lastLogin field.
func (r *userResolver) LastLogin(ctx context.Context, obj *model.User) (*string, error) {
	panic(fmt.Errorf("not implemented: LastLogin - lastLogin"))
}

// CreatedAt is the resolver for the created_at field.
func (r *userResolver) CreatedAt(ctx context.Context, obj *model.User) (string, error) {
	return time.Unix(int64(obj.CreatedAt.T), 0).Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updated_at field.
func (r *userResolver) UpdatedAt(ctx context.Context, obj *model.User) (string, error) {
	return time.Unix(int64(obj.UpdatedAt.T), 0).Format(time.RFC3339), nil
}

// Metadata is the resolver for the metadata field.
func (r *userResolver) Metadata(ctx context.Context, obj *model.User) (map[string]interface{}, error) {
	return obj.Metadata, nil
}

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }
