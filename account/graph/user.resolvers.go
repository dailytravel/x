package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/dailytravel/x/account/graph/model"
	"github.com/dailytravel/x/account/internal/utils"
	"github.com/dailytravel/x/account/pkg/auth"
	"github.com/go-redis/redis"
	jwt "github.com/golang-jwt/jwt/v4"
	"github.com/google/uuid"
	"github.com/typesense/typesense-go/typesense/api/pointer"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"golang.org/x/crypto/bcrypt"
)

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UserInput) (*model.User, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	filter := bson.M{"_id": _id}

	item := &model.User{
		Name:     input.Name,
		Email:    input.Email,
		Timezone: input.Timezone,
		Locale:   input.Locale,
		Picture:  input.Picture,
		Phone:    input.Phone,
		Status:   input.Status,
		Model: model.Model{
			UpdatedBy: uid,
		},
	}

	for _, role := range input.Roles {
		item.Roles = append(item.Roles, *role)
	}

	if err := r.db.Collection(item.Collection()).FindOneAndUpdate(ctx, filter, bson.M{"$set": item}).Decode(item); err != nil {
		return nil, err
	}

	return item, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*bool, error) {
	// Convert the string ID to MongoDB's ObjectID format
	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	// Delete the user from the database
	res, err := r.db.Collection("users").DeleteOne(ctx, bson.M{"_id": _id})
	if err != nil {
		return nil, err
	}

	// Check if any document was deleted
	if res.DeletedCount == 0 {
		return nil, nil
	}

	return pointer.True(), nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.UserInput) (*model.User, error) {
	// 1. Validate the input (you might have more validation rules)
	if input.Email == "" || input.Password == "" || input.Name == "" {
		return nil, fmt.Errorf("email, password and name are required")
	}

	// 2. Check if a user with the same email already exists
	var existingUser model.User
	err := r.db.Collection("users").FindOne(ctx, bson.M{"email": input.Email}).Decode(&existingUser)
	if err != nil && err != mongo.ErrNoDocuments {
		return nil, fmt.Errorf("error checking for existing user: %v", err)
	}

	// 3. Hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %v", err)
	}

	// 4. Create the user
	newUser := &model.User{
		Name:     input.Name,
		Email:    input.Email,
		Password: string(hashedPassword),
		// Add other fields from input if they exist
	}
	_, err = r.db.Collection("users").InsertOne(ctx, newUser)
	if err != nil {
		return nil, fmt.Errorf("failed to insert user: %v", err)
	}

	// 5. Return the created user (excluding the hashed password for security reasons)
	newUser.Password = ""
	return newUser, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.Payload, error) {
	var u *model.User
	var k *model.Key
	var a *model.Api
	var c *model.Client

	client := auth.APIKey(ctx)
	if client == nil {
		return nil, fmt.Errorf("client not found")
	}

	//check client
	if err := r.db.Collection("clients").FindOne(ctx, bson.M{"secret": client}, nil).Decode(&c); err != nil {
		return nil, fmt.Errorf("client not found")
	}

	//check api
	if err := r.db.Collection("apis").FindOne(ctx, bson.M{"identifier": "https://api.trip.express/graphql"}, nil).Decode(&a); err != nil {
		return nil, fmt.Errorf("api not found")
	}

	//find user by email
	if err := r.db.Collection(model.UserCollection).FindOne(ctx, bson.M{"email": email}, nil).Decode(&u); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	//check password
	if err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password)); err != nil {
		return nil, fmt.Errorf("password not match")
	}

	//get rsa key
	if err := r.db.Collection(model.KeyCollection).FindOne(ctx, bson.M{"status": "current"}, nil).Decode(&k); err != nil {
		return nil, fmt.Errorf("key not found")
	}

	//create token
	t := &model.Token{
		UID:       u.ID,
		Name:      "auth",
		Token:     uuid.NewString(),
		Abilities: []*string{pointer.String("*")},
		ExpiresAt: &primitive.Timestamp{T: uint32(time.Now().Add(time.Duration(time.Second * time.Duration(a.Expiration))).Unix())},
	}

	//insert token
	if _, err := r.db.Collection(t.Collection()).InsertOne(ctx, t); err != nil {
		return nil, err
	}

	access_token, err := auth.Token(jwt.MapClaims{
		"jti":      t.Token,
		"sub":      u.ID.Hex(),
		"email":    u.Email,
		"name":     u.Name,
		"locale":   u.Locale,
		"timezone": u.Timezone,
		"picture":  u.Picture,
		"roles":    strings.Join(u.Roles, " "),
		"scope":    "*",
		"aud":      a.Identifier,
		"iss":      strings.Join([]string{"https://", c.Domain}, ""),
		"azp":      c.ID.Hex(),
		"iat":      time.Now().Unix(),
		"exp":      t.ExpiresAt.T,
	}, *k)

	if err != nil {
		return nil, err
	}

	refresh_token, err := auth.Token(jwt.MapClaims{
		"jti": t.Token,
		"sub": u.ID.Hex(),
		"aud": a.Identifier,
		"iss": strings.Join([]string{"https://", c.Domain}, ""),
		"azp": c.ID.Hex(),
		"iat": time.Now().Unix(),
		"exp": time.Now().Add(time.Hour * 24 * 30).Unix(),
	}, *k)

	if err != nil {
		return nil, err
	}

	return &model.Payload{
		AccessToken:  *access_token,
		RefreshToken: *refresh_token,
		TokenType:    "Bearer",
		ExpiresIn:    3600,
	}, nil
}

// SocialLogin is the resolver for the socialLogin field.
func (r *mutationResolver) SocialLogin(ctx context.Context, provider model.SocialProvider, accessToken string) (*model.Payload, error) {
	var u *model.User
	var k *model.Key
	var a *model.Api
	var c *model.Client

	client := auth.APIKey(ctx)
	if client == nil {
		return nil, fmt.Errorf("client not found")
	}

	//check client
	if err := r.db.Collection("clients").FindOne(ctx, bson.M{"secret": client}, nil).Decode(&c); err != nil {
		return nil, fmt.Errorf("client not found")
	}
	// verify token from provider by google oauth
	email, err := auth.GoogleLogin(ctx, accessToken)
	if err != nil {
		return nil, err
	}

	// Check if the user already exists in the system
	if err := r.db.Collection("users").FindOne(ctx, bson.M{"email": email}, nil).Decode(&u); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	//get rsa key
	if err := r.db.Collection("keys").FindOne(ctx, bson.M{"status": "current"}, nil).Decode(&k); err != nil {
		return nil, fmt.Errorf("key not found")
	}

	access_token, err := auth.Token(jwt.MapClaims{
		"sub":   u.ID.Hex(),
		"roles": strings.Join(u.Roles, " "),
		"scope": "*",
		"aud":   a.Identifier,
		"iss":   strings.Join([]string{"https://", c.Domain}, ""),
		"azp":   c.ID.Hex(),
		"iat":   time.Now().Unix(),
		"exp":   time.Now().Add(time.Duration(time.Second * time.Duration(a.Expiration))).Unix(),
	}, *k)

	if err != nil {
		return nil, err
	}

	refresh_token, err := auth.Token(jwt.MapClaims{
		"sub": u.ID.Hex(),
		"aud": a.Identifier,
		"iss": strings.Join([]string{"https://", c.Domain}, ""),
		"azp": c.ID.Hex(),
		"iat": time.Now().Unix(),
		"exp": time.Now().Add(time.Hour * 24 * 30).Unix(),
	}, *k)

	if err != nil {
		return nil, err
	}

	return &model.Payload{
		AccessToken:  *access_token,
		RefreshToken: *refresh_token,
		TokenType:    "Bearer",
		ExpiresIn:    3600,
	}, nil
}

// UpdatePassword is the resolver for the updatePassword field.
func (r *mutationResolver) UpdatePassword(ctx context.Context, input model.PasswordInput) (*model.User, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	// Find item by ID
	var item *model.User
	if err := r.db.Collection(model.UserCollection).FindOne(ctx, bson.M{"_id": uid}).Decode(&item); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	// Check if new password and confirmation match
	if input.NewPassword != input.PasswordConfirmation {
		return nil, fmt.Errorf("passwords do not match")
	}

	// Check current password
	err = bcrypt.CompareHashAndPassword([]byte(item.Password), []byte(input.CurrentPassword))
	if err != nil {
		return nil, fmt.Errorf("current password is incorrect")
	}

	// Hash the new password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.NewPassword), 10)
	if err != nil {
		return nil, fmt.Errorf("error hashing the password")
	}

	// Update user's password
	_, err = r.db.Collection(model.UserCollection).UpdateOne(ctx, bson.M{"_id": uid}, bson.M{"$set": bson.M{"password": hashedPassword}})
	if err != nil {
		return nil, fmt.Errorf("error updating password")
	}

	return item, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, email string) (map[string]interface{}, error) {
	// Find user by email
	var user model.User
	if err := r.db.Collection(model.UserCollection).FindOne(ctx, bson.M{"email": email}).Decode(&user); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to retrieve user: %s", err.Error())
	}

	// Generate a unique code for the user
	code, err := utils.Base64(32, false)
	if err != nil {
		return nil, fmt.Errorf("failed to generate code: %s", err.Error())
	}

	// Store the code in Redis for 24 hours
	err = r.redis.Set(ctx, code, user.ID.Hex(), time.Hour*24).Err()
	if err != nil {
		return nil, fmt.Errorf("failed to store code: %s", err.Error())
	}

	// Return a response
	response := map[string]interface{}{
		"message": "A password reset email has been sent.",
	}
	return response, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, token string, password string, passwordConfirmation string) (map[string]interface{}, error) {
	// Retrieve email from Redis
	email, err := r.redis.Get(ctx, token).Result()
	if err == redis.Nil {
		return nil, fmt.Errorf("invalid token")
	} else if err != nil {
		return nil, fmt.Errorf("failed to retrieve token from Redis: %s", err.Error())
	}

	// Hash password
	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %s", err.Error())
	}

	// Update user password
	result, err := r.db.Collection(model.UserCollection).UpdateOne(
		ctx,
		bson.M{"email": email},
		bson.M{"$set": bson.M{"password": hash}},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update user password: %s", err.Error())
	} else if result.ModifiedCount == 0 {
		return nil, fmt.Errorf("user not found")
	}

	// Delete token from Redis
	deleted, err := r.redis.Del(ctx, token).Result()
	if err != nil {
		return nil, fmt.Errorf("failed to delete token from Redis: %s", err.Error())
	} else if deleted == 0 {
		return nil, fmt.Errorf("invalid token")
	}

	return map[string]interface{}{
		"code": nil,
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, args map[string]interface{}) (map[string]interface{}, error) {
	res, err := r.ts.Collection(model.UserCollection).Documents().Search(utils.Params(args))
	if err != nil {
		return nil, err
	}

	// Convert struct to map
	results, err := utils.StructToMap(res)
	if err != nil {
		return nil, err
	}

	return results, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	var item *model.User
	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	filter := bson.M{"_id": _id}
	options := options.FindOne().SetProjection(bson.M{"_id": 1, "name": 1, "email": 1, "photos": 1})

	if err := r.db.Collection(item.Collection()).FindOne(ctx, filter, options).Decode(&item); err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, fmt.Errorf("no document found for filter %v", filter)
		}
		return nil, err
	}

	return item, nil
}

// Owners is the resolver for the owners field.
func (r *queryResolver) Owners(ctx context.Context, ids []string, limit *int, offset *int) (*model.Users, error) {
	var users []*model.User

	// Convert string IDs to ObjectIDs
	objectIds := make([]primitive.ObjectID, 0, len(ids))
	for _, idStr := range ids {
		objectId, err := primitive.ObjectIDFromHex(idStr)
		if err != nil {
			return nil, fmt.Errorf("invalid _id format: %s", idStr)
		}
		objectIds = append(objectIds, objectId)
	}

	// Construct the query
	query := bson.M{"_id": bson.M{"$in": objectIds}}

	opts := options.Find()
	if limit != nil {
		opts.SetLimit(int64(*limit))
	}

	if offset != nil {
		opts.SetSkip(int64(*offset))
	}

	// Fetch the users based on the filter and pagination options
	cursor, err := r.db.Collection("users").Find(ctx, query, opts)
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	// Decode each found document into a user struct
	for cursor.Next(ctx) {
		var user model.User
		if err := cursor.Decode(&user); err != nil {
			return nil, err
		}
		users = append(users, &user)
	}

	// In case there's an error during the cursor iteration
	if err := cursor.Err(); err != nil {
		return nil, err
	}

	// Get the total count of users based on the filter
	count, err := r.db.Collection("users").CountDocuments(ctx, query)
	if err != nil {
		return nil, err
	}

	return &model.Users{
		Count: int(count),
		Data:  users,
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	var item *model.User
	//find user by id
	if err := r.db.Collection(model.UserCollection).FindOne(ctx, bson.M{"_id": uid}, nil).Decode(&item); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	return item, nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *model.User) (string, error) {
	return obj.ID.Hex(), nil
}

// EmailVerifiedAt is the resolver for the emailVerifiedAt field.
func (r *userResolver) EmailVerifiedAt(ctx context.Context, obj *model.User) (*string, error) {
	if obj.EmailVerifiedAt == nil {
		return nil, nil
	}

	return pointer.String(time.Unix(int64(obj.EmailVerifiedAt.T), 0).Format(time.RFC3339)), nil
}

// PhoneVerifiedAt is the resolver for the phoneVerifiedAt field.
func (r *userResolver) PhoneVerifiedAt(ctx context.Context, obj *model.User) (*string, error) {
	if obj.PhoneVerifiedAt == nil {
		return nil, nil
	}

	return pointer.String(time.Unix(int64(obj.PhoneVerifiedAt.T), 0).Format(time.RFC3339)), nil
}

// CreatedAt is the resolver for the created_at field.
func (r *userResolver) CreatedAt(ctx context.Context, obj *model.User) (string, error) {
	return time.Unix(int64(obj.CreatedAt.T), 0).Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updated_at field.
func (r *userResolver) UpdatedAt(ctx context.Context, obj *model.User) (string, error) {
	return time.Unix(int64(obj.UpdatedAt.T), 0).Format(time.RFC3339), nil
}

// Metadata is the resolver for the metadata field.
func (r *userResolver) Metadata(ctx context.Context, obj *model.User) (map[string]interface{}, error) {
	return obj.Metadata, nil
}

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }
