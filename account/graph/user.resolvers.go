package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/dailytravel/x/account/graph/model"
	"github.com/dailytravel/x/account/internal/utils"
	"github.com/dailytravel/x/account/pkg/auth"
	"github.com/go-redis/redis"
	jwt "github.com/golang-jwt/jwt/v4"
	"github.com/google/uuid"
	"github.com/typesense/typesense-go/typesense/api/pointer"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"golang.org/x/crypto/bcrypt"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUserInput) (*model.User, error) {
	// Check if a user with the same email already exists
	var existingUser model.User
	if err := r.db.Collection("users").FindOne(ctx, bson.M{"email": input.Email}).Decode(&existingUser); err != nil {
		if err != mongo.ErrNoDocuments {
			return nil, fmt.Errorf("error checking for existing user: %v", err)
		}
	}

	// Hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %v", err)
	}

	// Create the user
	item := &model.User{
		Name:   input.Name,
		Email:  input.Email,
		Status: pointer.String("PENDING"), // Use a constant or enum for status
	}

	// Insert the user
	res, err := r.db.Collection("users").InsertOne(ctx, item)
	if err != nil {
		return nil, fmt.Errorf("failed to insert user: %v", err)
	}

	// Create the password credential
	credential := &model.Credential{
		UID:     item.ID,
		Type:    "PASSWORD", // Use a constant or enum for type
		Secret:  string(hashedPassword),
		Expires: primitive.Timestamp{T: uint32(time.Now().Add(time.Hour * 24 * 90).Unix())},
		Status:  "ACTIVE", // Use a constant or enum for status
	}

	// Insert the credential
	if _, err := r.db.Collection("credentials").InsertOne(ctx, credential); err != nil {
		return nil, fmt.Errorf("failed to insert credential: %v", err)
	}

	item.ID = res.InsertedID.(primitive.ObjectID)
	return item, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*model.User, error) {
	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	filter := bson.M{"_id": _id}

	// Find the user and ensure they exist
	user := &model.User{}

	if err := r.db.Collection("users").FindOne(ctx, filter).Decode(&user); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("error fetching user: %s", err.Error())
	}

	if input.Name != nil {
		user.Name = *input.Name
	}

	if input.Picture != nil {
		user.Picture = input.Picture
	}

	if input.Locale != nil {
		user.Locale = input.Locale
	}

	if input.Timezone != nil {
		user.Timezone = input.Timezone
	}

	if input.Roles != nil {
		user.Roles = input.Roles
	}

	if input.Status != nil {
		user.Status = input.Status
	}

	if input.Metadata != nil {
		if user.Metadata == nil {
			user.Metadata = make(map[string]interface{})
		}

		for k, v := range input.Metadata {
			user.Metadata[k] = v
		}
	}

	// Update the user in the database
	result, err := r.db.Collection("users").UpdateOne(ctx, filter, bson.M{"$set": user})
	if err != nil || result.ModifiedCount == 0 {
		return nil, fmt.Errorf("failed to update user: %v", err)
	}

	return user, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	clientID, err := primitive.ObjectIDFromHex(*input.ClientID)
	if err != nil {
		return nil, fmt.Errorf("invalid client ID: %v", err)
	}

	client, err := r.getClientByID(ctx, clientID)
	if err != nil {
		return nil, fmt.Errorf("client not found: %v", err)
	}

	_, err = r.getUserByEmail(ctx, input.Email)
	if err != nil {
		return nil, fmt.Errorf("error checking for existing user: %v", err)
	}

	api, err := r.getAPIByIdentifier(ctx, client.Domain)
	if err != nil {
		return nil, fmt.Errorf("api not found: %v", err)
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %v", err)
	}

	user := &model.User{
		Name:   input.Name,
		Email:  input.Email,
		Status: pointer.String("PENDING"), // Use a constant or enum for status
	}

	if err := r.insertUser(ctx, user); err != nil {
		return nil, fmt.Errorf("failed to insert user: %v", err)
	}

	credentials := []interface{}{}
	credentials = append(credentials, utils.Credential(*user, "PASSWORD", string(hashedPassword), &primitive.Timestamp{T: uint32(time.Now().Add(time.Hour * 24 * 90).Unix())}))

	for _, code := range utils.RecoveryCodes(10, 8) {
		credentials = append(credentials, utils.Credential(*user, "BACKUP_CODE", code, nil))
	}

	if err := r.insertCredentials(ctx, credentials); err != nil {
		return nil, fmt.Errorf("failed to insert credential: %v", err)
	}

	token, err := r.insertToken(ctx, &model.Token{
		UID:    user.ID,
		Client: client.ID,
		Token:  uuid.New().String(),
		Expires: primitive.Timestamp{
			T: uint32(time.Now().Add(time.Hour * 24 * 90).Unix()),
			I: 0,
		},
		ClientIP:  *auth.ClientIP(ctx),
		UserAgent: *auth.UserAgent(ctx),
	})

	if err != nil {
		return nil, fmt.Errorf("failed to insert token: %v", err)
	}

	// Generate a new access token
	accessToken, err := r.generateTokens(ctx, user, jwt.MapClaims{
		"jti":      token.ID.Hex(),
		"sub":      user.ID.Hex(),
		"email":    user.Email,
		"name":     user.Name,
		"locale":   user.Locale,
		"timezone": user.Timezone,
		"picture":  user.Picture,
		"roles":    user.Roles,
		"scope":    "*",
		"aud":      api.Identifier,
		"iss":      "https://api.trip.express/graphql",
		"azp":      client.ID.Hex(),
		"iat":      time.Now().Unix(),
		"exp":      time.Now().Add(time.Duration(time.Second * time.Duration(api.Expiration))).Unix(),
	})

	if err != nil {
		return nil, fmt.Errorf("error generating tokens: %v", err)
	}

	// Send email verification
	// emailData := map[string]interface{}{
	// 	"name":  user.Name,
	// 	"email": user.Email,
	// }

	// Marshal the map into a JSON string
	// jsonData, err := json.Marshal(emailData)
	// if err != nil {
	// 	fmt.Println("Error marshaling JSON:", err)
	// 	return nil, err
	// }

	// Return the access token and refresh token
	return &model.AuthPayload{
		AccessToken:  accessToken,
		RefreshToken: pointer.String(token.Token),
		TokenType:    pointer.String("Bearer"),
		ExpiresIn:    pointer.Int(int(api.Expiration)),
	}, nil
}

// VerifyEmail is the resolver for the verifyEmail field.
func (r *mutationResolver) VerifyEmail(ctx context.Context, token string) (map[string]interface{}, error) {
	// Retrieve the user's email or ID from the token. This could be stored in Redis or another cache.
	id, err := r.redis.Get(ctx, token).Result() // using Redis as an example
	if err == redis.Nil {
		return nil, fmt.Errorf("invalid or expired token")
	} else if err != nil {
		return nil, fmt.Errorf("failed to retrieve token data: %s", err.Error())
	}

	// Convert the string ID to MongoDB's ObjectID format
	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user id: %s", err.Error())
	}

	// Define a filter to fetch the user by their email or ID.
	// Depending on what's stored in the token, adjust the filter accordingly.
	filter := bson.M{"_id": _id} // assuming the token stored the email, adjust if it's an ID or something else

	// Find the user and ensure they exist
	var user *model.User
	err = r.db.Collection("users").FindOne(ctx, filter).Decode(&user)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("error fetching user: %s", err.Error())
	}

	// Check if the user's email is already verified
	if *user.EmailVerified {
		return nil, fmt.Errorf("email is already verified")
	}

	// Update the user's EmailVerified status
	update := bson.M{"$set": bson.M{"emailVerified": true}}
	_, err = r.db.Collection("users").UpdateOne(ctx, filter, update)
	if err != nil {
		return nil, fmt.Errorf("error updating email verification status: %s", err.Error())
	}

	// Optionally, remove the token so it can't be used again
	_, err = r.redis.Del(ctx, token).Result()
	if err != nil {
		// This isn't a critical error, but you may want to log it for audit purposes.
		fmt.Printf("Warning: failed to delete token from cache: %s\n", err.Error())
	}

	// Return a success message
	return map[string]interface{}{
		"message": "Email successfully verified.",
		"email":   user.Email,
	}, nil
}

// VerifyPhone is the resolver for the verifyPhone field.
func (r *mutationResolver) VerifyPhone(ctx context.Context, token string) (map[string]interface{}, error) {
	// Retrieve the user's phone number or ID from the token. This could be stored in Redis or another cache.
	id, err := r.redis.Get(ctx, token).Result() // using Redis as an example
	if err == redis.Nil {
		return nil, fmt.Errorf("invalid or expired token")
	} else if err != nil {
		return nil, fmt.Errorf("failed to retrieve token data: %s", err.Error())
	}

	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user id: %s", err.Error())
	}

	// Define a filter to fetch the user by their phone number or ID.
	// Depending on what's stored in the token, adjust the filter accordingly.
	filter := bson.M{"_id": _id} // assuming the token stored the phone number, adjust if it's an ID or something else

	// Find the user and ensure they exist
	var user *model.User
	err = r.db.Collection("users").FindOne(ctx, filter).Decode(&user)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("error fetching user: %s", err.Error())
	}

	// Check if the user's phone is already verified
	if *user.PhoneVerified {
		return nil, fmt.Errorf("phone number is already verified")
	}

	// Update the user's PhoneVerified status
	update := bson.M{"$set": bson.M{"phoneVerified": true}}
	_, err = r.db.Collection("users").UpdateOne(ctx, filter, update)
	if err != nil {
		return nil, fmt.Errorf("error updating phone verification status: %s", err.Error())
	}

	// Optionally, remove the token so it can't be used again
	_, err = r.redis.Del(ctx, token).Result()
	if err != nil {
		// This isn't a critical error, but you may want to log it for audit purposes.
		fmt.Printf("Warning: failed to delete token from cache: %s\n", err.Error())
	}

	// Return a success message
	return map[string]interface{}{
		"message": "Phone number successfully verified.",
		"phone":   user.Phone,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	clientID, err := primitive.ObjectIDFromHex(*input.ClientID)
	if err != nil {
		return nil, fmt.Errorf("invalid client ID: %v", err)
	}

	client, err := r.getClientByID(ctx, clientID)
	if err != nil {
		return nil, fmt.Errorf("client not found: %v", err)
	}

	api, err := r.getAPIByIdentifier(ctx, client.Domain)
	if err != nil {
		return nil, fmt.Errorf("api not found: %v", err)
	}

	user, err := r.getUserByEmail(ctx, input.Username)
	if err != nil {
		return nil, fmt.Errorf("error checking for existing user: %v", err)
	}

	pwd, err := r.getCredentialPassword(ctx, user.ID)
	if err != nil {
		return nil, fmt.Errorf("client not found: %v", err)
	}

	//check password
	if err := bcrypt.CompareHashAndPassword([]byte(pwd.Secret), []byte(input.Password)); err != nil {
		return nil, fmt.Errorf("password not match")
	}

	token, err := r.insertToken(ctx, &model.Token{
		UID:    user.ID,
		Client: client.ID,
		Token:  uuid.New().String(),
		Expires: primitive.Timestamp{
			T: uint32(time.Now().Add(time.Hour * 24 * 90).Unix()),
			I: 0,
		},
		ClientIP:  *auth.ClientIP(ctx),
		UserAgent: *auth.UserAgent(ctx),
	})

	if err != nil {
		return nil, fmt.Errorf("failed to insert token: %v", err)
	}

	// Generate a new access token
	accessToken, err := r.generateTokens(ctx, user, jwt.MapClaims{
		"jti":      token.ID.Hex(),
		"sub":      user.ID.Hex(),
		"email":    user.Email,
		"name":     user.Name,
		"locale":   user.Locale,
		"timezone": user.Timezone,
		"picture":  user.Picture,
		"roles":    user.Roles,
		"scope":    "*",
		"aud":      api.Identifier,
		"iss":      "https://api.trip.express/graphql",
		"azp":      client.ID.Hex(),
		"iat":      time.Now().Unix(),
		"exp":      time.Now().Add(time.Duration(time.Second * time.Duration(api.Expiration))).Unix(),
	})

	if err != nil {
		return nil, fmt.Errorf("error generating tokens: %v", err)
	}

	// Return the access token and refresh token
	return &model.AuthPayload{
		AccessToken:  accessToken,
		RefreshToken: pointer.String(token.Token),
		TokenType:    pointer.String("Bearer"),
		ExpiresIn:    pointer.Int(int(api.Expiration)),
	}, nil
}

// Verify 2FA is the resolver for the verify field.
func (r *mutationResolver) Verify(ctx context.Context, input model.VerifyInput) (map[string]interface{}, error) {
	// Retrieve the token's ID from the cache (e.g., Redis).
	tokenID, err := r.redis.Get(ctx, input.Code).Result()
	if err == redis.Nil {
		return nil, fmt.Errorf("invalid or expired token")
	} else if err != nil {
		return nil, fmt.Errorf("failed to retrieve token data: %s", err.Error())
	}

	id, err := primitive.ObjectIDFromHex(tokenID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %s", err.Error())
	}

	var token *model.Token
	if err := r.db.Collection("tokens").FindOne(ctx, bson.M{"_id": id, "revoked": false}).Decode(&token); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("token not found")
		}
		return nil, fmt.Errorf("error fetching token: %s", err.Error())
	}

	// Update the token value to indicate successful authentication.
	_, err = r.db.Collection("tokens").UpdateOne(ctx, token.ID, bson.M{
		"$set": bson.M{
			"authenticated": true,
			"last_used":     primitive.Timestamp{T: uint32(time.Now().Unix())},
		},
	})

	if err != nil {
		return nil, fmt.Errorf("failed to update token data: %s", err.Error())
	}

	return map[string]interface{}{
		"message": "2FA successfully verified.",
	}, nil
}

// SocialLogin is the resolver for the socialLogin field.
func (r *mutationResolver) SocialLogin(ctx context.Context, input model.SocialLoginInput) (*model.AuthPayload, error) {
	var user *model.User
	var client *model.Client
	var identity *model.Identity

	clientID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}

	if err := r.db.Collection("clients").FindOne(ctx, bson.M{"_id": clientID}, nil).Decode(&client); err != nil {
		return nil, fmt.Errorf("client not found")
	}

	api, err := r.getAPIByIdentifier(ctx, client.Domain)
	if err != nil {
		return nil, fmt.Errorf("api not found: %v", err)
	}

	userInfo, err := utils.FetchUserInfo(input.Token, input.Provider)
	if err != nil {
		return nil, err
	}

	var data map[string]interface{}
	if err := json.Unmarshal([]byte(userInfo), &data); err != nil {
		return nil, err
	}

	if err := r.db.Collection("identities").FindOne(ctx, bson.M{"provider": input.Provider, "user_id": data["sub"]}, nil).Decode(&identity); err != nil {
		// Identity not found, check for the user
		if err := r.db.Collection("users").FindOne(ctx, bson.M{"email": data["email"]}, nil).Decode(&user); err != nil {
			// User not found, create a new user
			item := &model.User{
				Name:    data["name"].(string),
				Email:   data["email"].(string),
				Picture: pointer.String(data["picture"].(string)),
				Status:  pointer.String("ACTIVE"),
			}
			res, err := r.db.Collection("users").InsertOne(ctx, item)
			if err != nil {
				return nil, fmt.Errorf("failed to insert user: %v", err)
			}
			item.ID = res.InsertedID.(primitive.ObjectID)
			user = item

			credentials := []interface{}{}
			for _, code := range utils.RecoveryCodes(10, 8) {
				credentials = append(credentials, utils.Credential(*user, "BACKUP_CODE", code, nil))
			}

			if err := r.insertCredentials(ctx, credentials); err != nil {
				return nil, fmt.Errorf("failed to insert credential: %v", err)
			}
		}
		// Create a new identity
		item := &model.Identity{
			Provider:   input.Provider,
			UserID:     data["sub"].(string),
			UID:        user.ID,
			IsSocial:   true,
			Connection: "google-oauth2",
			Status:     "ACTIVE",
		}

		if _, err := r.db.Collection("identities").InsertOne(ctx, item); err != nil {
			return nil, fmt.Errorf("failed to insert identity: %v", err)
		}
	} else if err := r.db.Collection("users").FindOne(ctx, bson.M{"_id": identity.UID}, nil).Decode(&user); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	token, err := r.insertToken(ctx, &model.Token{
		UID:    user.ID,
		Client: client.ID,
		Token:  uuid.New().String(),
		Expires: primitive.Timestamp{
			T: uint32(time.Now().Add(time.Hour * 24 * 90).Unix()),
			I: 0,
		},
		ClientIP:  *auth.ClientIP(ctx),
		UserAgent: *auth.UserAgent(ctx),
	})

	if err != nil {
		return nil, fmt.Errorf("failed to insert token: %v", err)
	}

	// Generate a new access token
	accessToken, err := r.generateTokens(ctx, user, jwt.MapClaims{
		"jti":      token.ID.Hex(),
		"sub":      user.ID.Hex(),
		"email":    user.Email,
		"name":     user.Name,
		"locale":   user.Locale,
		"timezone": user.Timezone,
		"picture":  user.Picture,
		"roles":    user.Roles,
		"scope":    "*",
		"aud":      api.Identifier,
		"iss":      "https://api.trip.express/graphql",
		"azp":      client.ID.Hex(),
		"iat":      time.Now().Unix(),
		"exp":      time.Now().Add(time.Duration(time.Second * time.Duration(api.Expiration))).Unix(),
	})

	if err != nil {
		return nil, fmt.Errorf("error generating tokens: %v", err)
	}

	// Return the access token and refresh token
	return &model.AuthPayload{
		AccessToken:  accessToken,
		RefreshToken: pointer.String(token.Token),
		TokenType:    pointer.String("Bearer"),
		ExpiresIn:    pointer.Int(int(api.Expiration)),
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, token string) (*model.AuthPayload, error) {
	id, err := primitive.ObjectIDFromHex(token)
	if err != nil {
		return nil, fmt.Errorf("invalid refresh token")
	}

	var _token *model.Token
	if err := r.db.Collection("tokens").FindOne(ctx, bson.M{"_id": id, "revoked": false, "expires": bson.M{"$gt": primitive.Timestamp{T: uint32(time.Now().Unix())}}}).Decode(&_token); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("token not found")
		}
		return nil, fmt.Errorf("error fetching token: %s", err.Error())
	}

	var client *model.Client
	err = r.db.Collection("clients").FindOne(ctx, bson.M{"_id": _token.Client}).Decode(&client)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("client not found")
		}
		return nil, fmt.Errorf("error fetching client: %s", err.Error())
	}

	var api *model.Api
	if err := r.db.Collection("apis").FindOne(ctx, bson.M{"identifier": client.Domain}).Decode(&api); err != nil {
		return nil, fmt.Errorf("api not found")
	}

	var user *model.User
	if err := r.db.Collection("users").FindOne(ctx, bson.M{"_id": _token.UID}).Decode(&user); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	// Generate a new access token
	accessToken, err := r.generateTokens(ctx, user, jwt.MapClaims{
		"jti":      _token.ID.Hex(),
		"sub":      user.ID.Hex(),
		"email":    user.Email,
		"name":     user.Name,
		"locale":   user.Locale,
		"timezone": user.Timezone,
		"picture":  user.Picture,
		"roles":    user.Roles,
		"scope":    "*",
		"aud":      api.Identifier,
		"iss":      "https://api.trip.express/graphql",
		"azp":      client.ID.Hex(),
		"iat":      time.Now().Unix(),
		"exp":      time.Now().Add(time.Duration(time.Second * time.Duration(api.Expiration))).Unix(),
	})

	if err != nil {
		return nil, fmt.Errorf("error generating tokens: %v", err)
	}

	// Return the access token and refresh token
	return &model.AuthPayload{
		AccessToken:  accessToken,
		RefreshToken: pointer.String(_token.ID.Hex()),
		TokenType:    pointer.String("Bearer"),
		ExpiresIn:    pointer.Int(int(api.Expiration)),
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context, all *bool) (map[string]interface{}, error) {
	// Authenticate the request
	claims := auth.Auth(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	uid, err := primitive.ObjectIDFromHex(claims["sub"].(string))
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	// Define the common filter for token revocation
	filter := bson.M{"uid": uid}

	// Handle global logout or token-specific logout
	update := bson.M{"$set": bson.M{"revoked": true}}
	if all != nil && *all {
		var tokens []*model.Token
		// Global logout: Revoke all refresh tokens
		_, err := r.db.Collection("tokens").UpdateMany(ctx, filter, update)
		if err != nil {
			return nil, fmt.Errorf("failed to revoke tokens: %v", err)
		}

		// Retrieve all revoked tokens
		cursor, err := r.db.Collection("tokens").Find(ctx, bson.M{"uid": uid, "revoked": true}, options.Find().SetProjection(bson.M{"_id": 1}))
		if err != nil {
			return nil, fmt.Errorf("failed to retrieve revoked tokens: %v", err)
		}

		// Check if the user has any revoked tokens
		if err := cursor.All(ctx, &tokens); err != nil {
			return nil, fmt.Errorf("failed to retrieve revoked tokens: %v", err)
		}

		for _, token := range tokens {
			//update many to revoked tokens from MongoDB
			if _, err := r.db.Collection("tokens").UpdateMany(ctx, bson.M{"_id": token.ID}, update); err != nil {
				return nil, fmt.Errorf("failed to revoke tokens: %v", err)
			}
		}

	} else {
		// Token-specific logout: Revoke a specific token by JTI
		jtiClaim, exists := claims["jti"]
		if !exists {
			return nil, fmt.Errorf("jti claim is missing")
		}

		jti, err := primitive.ObjectIDFromHex(jtiClaim.(string))
		if err != nil {
			return nil, fmt.Errorf("invalid jti")
		}

		if _, err = r.db.Collection("tokens").UpdateOne(ctx, bson.M{"_id": jti}, update); err != nil {
			return nil, fmt.Errorf("failed to revoke token: %v", err)
		}

		// Optionally, remove the token from Redis so it can't be used again
		if _, err = r.db.Collection("tokens").UpdateOne(ctx, bson.M{"_id": jti}, update); err != nil {
			// This isn't a critical error, but you may want to log it for audit purposes.
			fmt.Printf("Warning: failed to delete token from cache: %s\n", err.Error())
		}
	}

	return map[string]interface{}{
		"message": "Successfully logged out.",
	}, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, email string) (map[string]interface{}, error) {
	// Find user by email
	var user model.User
	if err := r.db.Collection("users").FindOne(ctx, bson.M{"email": email}).Decode(&user); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to retrieve user: %s", err.Error())
	}

	// Store the code in Redis for 24 hours
	if err := r.redis.Set(ctx, uuid.New().String(), user.ID.Hex(), time.Hour*24).Err(); err != nil {
		return nil, fmt.Errorf("failed to store code: %s", err.Error())
	}

	// Return a response
	response := map[string]interface{}{
		"message": "A password reset email has been sent.",
	}

	return response, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (map[string]interface{}, error) {
	var credentials []*model.Credential
	// Retrieve userId from Redis
	userId, err := r.redis.Get(ctx, input.Token).Result()
	if err != nil {
		if err == redis.Nil {
			return nil, fmt.Errorf("invalid token")
		}
		return nil, fmt.Errorf("failed to retrieve token from Redis: %v", err)
	}

	if input.Password != input.PasswordConfirmation {
		return nil, errors.New("passwords do not match")
	}

	// Convert userID to ObjectID
	id, err := primitive.ObjectIDFromHex(userId)
	if err != nil {
		return nil, fmt.Errorf("invalid user id: %v", err)
	}

	// Retrieve user by ID
	var user *model.User
	if err := r.db.Collection("users").FindOne(ctx, bson.M{"_id": id}).Decode(&user); err != nil {
		return nil, fmt.Errorf("failed to retrieve user: %v", err)
	}

	// Retrieve all credentials for the user
	cursor, err := r.db.Collection("credentials").Find(ctx, bson.M{"uid": user.ID, "type": "PASSWORD"})
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve credentials: %v", err)
	}

	// Check if the user has any credentials
	if err := cursor.All(ctx, &credentials); err != nil {
		return nil, fmt.Errorf("failed to retrieve credentials: %v", err)
	}

	// Check if the user has any credentials
	if len(credentials) == 0 {
		return nil, fmt.Errorf("user has no credentials")
	}

	for _, credential := range credentials {
		//check existing password
		if err := bcrypt.CompareHashAndPassword([]byte(credential.Secret), []byte(input.Password)); err == nil {
			return nil, fmt.Errorf("new password cannot be the same as the previous passwords")
		}
	}

	// Hash the new password
	hash, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %v", err)
	}

	// Create a new password struct
	credential := &model.Credential{
		UID:     user.ID,
		Type:    "PASSWORD", // Use a constant or enum for type
		Secret:  string(hash),
		Expires: primitive.Timestamp{T: uint32(time.Now().Add(time.Hour * 24 * 90).Unix())},
		Status:  "ACTIVE", // Use a constant or enum for status
	}

	// Insert the credential
	if _, err := r.db.Collection("credentials").InsertOne(ctx, credential); err != nil {
		return nil, fmt.Errorf("failed to insert credential: %v", err)
	}

	// Delete the token from Redis
	if _, err := r.redis.Del(ctx, input.Token).Result(); err != nil {
		return nil, fmt.Errorf("failed to delete token from Redis: %v", err)
	}

	return map[string]interface{}{
		"message": "Password updated successfully.",
		"email":   user.Email,
	}, nil
}

// UpdatePassword is the resolver for the UpdatePassword field.
func (r *mutationResolver) UpdatePassword(ctx context.Context, input model.UpdatePasswordInput) (map[string]interface{}, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	//check password and password confirmation
	if input.PasswordConfirmation != nil && input.Password != *input.PasswordConfirmation {
		return nil, errors.New("passwords do not match")
	}

	var credentials []*model.Credential

	// Retrieve all credentials for the user
	cursor, err := r.db.Collection("credentials").Find(ctx, bson.M{"uid": uid, "type": "PASSWORD"})
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve credentials: %v", err)
	}

	// Check if the user has any credentials
	if err := cursor.All(ctx, &credentials); err != nil {
		return nil, fmt.Errorf("failed to retrieve credentials: %v", err)
	}

	// Check if the user has any credentials
	if len(credentials) == 0 {
		return nil, fmt.Errorf("user has no credentials")
	}

	//check old password
	for _, credential := range credentials {
		//check existing password
		if err := bcrypt.CompareHashAndPassword([]byte(credential.Secret), []byte(input.OldPassword)); err != nil {
			return nil, fmt.Errorf("old password is not correct")
		}

		//check new password
		if err := bcrypt.CompareHashAndPassword([]byte(credential.Secret), []byte(input.Password)); err == nil {
			return nil, fmt.Errorf("new password cannot be the same as the previous passwords")
		}
	}

	// Hash the new password
	hash, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %v", err)
	}

	// Create a new password struct
	credential := &model.Credential{
		UID:     *uid,
		Type:    "PASSWORD", // Use a constant or enum for type
		Secret:  string(hash),
		Expires: primitive.Timestamp{T: uint32(time.Now().Add(time.Hour * 24 * 90).Unix())},
		Status:  "ACTIVE", // Use a constant or enum for status
	}

	// Insert the credential
	if _, err := r.db.Collection("credentials").InsertOne(ctx, credential); err != nil {
		return nil, fmt.Errorf("failed to insert credential: %v", err)
	}

	return map[string]interface{}{
		"message": "Password updated successfully.",
	}, nil
}

// Deactivate is the resolver for the deactivate field.
func (r *mutationResolver) Deactivate(ctx context.Context) (*model.User, error) {
	// Retrieve the user ID from context
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	// Find the user by ID and ensure they exist
	filter := bson.M{"_id": uid}
	var user *model.User
	err = r.db.Collection("users").FindOne(ctx, filter).Decode(&user)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("error fetching user: %s", err.Error())
	}

	// Check if the user is already deactivated
	if user.Status == pointer.String("DEACTIVATED") {
		return nil, fmt.Errorf("user is already deactivated")
	}

	// Update user status to deactivated
	update := bson.M{"$set": bson.M{"status": "DEACTIVATED"}}
	_, err = r.db.Collection("users").UpdateOne(ctx, filter, update)
	if err != nil {
		return nil, fmt.Errorf("error deactivating user: %s", err.Error())
	}

	// Return the updated user (you may choose to fetch the latest state from DB if required)
	user.Status = pointer.String("DEACTIVATED")
	return user, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*bool, error) {
	// Convert the string ID to MongoDB's ObjectID format
	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	// Delete the user from the database
	res, err := r.db.Collection("users").DeleteOne(ctx, bson.M{"_id": _id})
	if err != nil {
		return nil, err
	}

	// Check if any document was deleted
	if res.DeletedCount == 0 {
		return nil, nil
	}

	return pointer.True(), nil
}

// DeleteUsers is the resolver for the deleteUsers field.
func (r *mutationResolver) DeleteUsers(ctx context.Context, ids []string) (*bool, error) {
	// Convert string IDs to ObjectIDs
	objectIDs := make([]primitive.ObjectID, len(ids))
	for i, id := range ids {
		oid, err := primitive.ObjectIDFromHex(id)
		if err != nil {
			return nil, fmt.Errorf("invalid ID format: %s", id)
		}
		objectIDs[i] = oid
	}

	// Create filter to delete multiple users based on their ObjectIDs
	filter := bson.M{"_id": bson.M{"$in": objectIDs}}

	// Delete users from the database
	result, err := r.db.Collection("users").DeleteMany(ctx, filter)
	if err != nil {
		return nil, fmt.Errorf("error deleting users: %s", err.Error())
	}

	// If no users were deleted, return false
	if result.DeletedCount == 0 {
		return nil, fmt.Errorf("no users found to delete")
	}

	// Return true if successful
	return pointer.True(), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, args map[string]interface{}) (map[string]interface{}, error) {
	res, err := r.ts.Collection("users").Documents().Search(utils.Params(args))
	if err != nil {
		return nil, err
	}

	// Convert struct to map
	results, err := utils.StructToMap(res)
	if err != nil {
		return nil, err
	}

	return results, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	var item *model.User
	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	filter := bson.M{"_id": _id}
	options := options.FindOne().SetProjection(bson.M{"_id": 1, "name": 1, "email": 1, "photos": 1})

	if err := r.db.Collection(item.Collection()).FindOne(ctx, filter, options).Decode(&item); err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, fmt.Errorf("no document found for filter %v", filter)
		}
		return nil, err
	}

	return item, nil
}

// Owners is the resolver for the owners field.
func (r *queryResolver) Owners(ctx context.Context, ids []string, limit *int, offset *int) (*model.Users, error) {
	var users []*model.User

	// Convert string IDs to ObjectIDs
	objectIds := make([]primitive.ObjectID, 0, len(ids))
	for _, idStr := range ids {
		objectId, err := primitive.ObjectIDFromHex(idStr)
		if err != nil {
			return nil, fmt.Errorf("invalid _id format: %s", idStr)
		}
		objectIds = append(objectIds, objectId)
	}

	// Construct the query
	query := bson.M{"_id": bson.M{"$in": objectIds}}

	opts := options.Find()
	if limit != nil {
		opts.SetLimit(int64(*limit))
	}

	if offset != nil {
		opts.SetSkip(int64(*offset))
	}

	// Fetch the users based on the filter and pagination options
	cursor, err := r.db.Collection("users").Find(ctx, query, opts)
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	// Decode each found document into a user struct
	for cursor.Next(ctx) {
		var user model.User
		if err := cursor.Decode(&user); err != nil {
			return nil, err
		}
		users = append(users, &user)
	}

	// In case there's an error during the cursor iteration
	if err := cursor.Err(); err != nil {
		return nil, err
	}

	// Get the total count of users based on the filter
	count, err := r.db.Collection("users").CountDocuments(ctx, query)
	if err != nil {
		return nil, err
	}

	return &model.Users{
		Count: int(count),
		Data:  users,
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	var item *model.User
	//find user by id
	if err := r.db.Collection("users").FindOne(ctx, bson.M{"_id": uid}, nil).Decode(&item); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	return item, nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *model.User) (string, error) {
	return obj.ID.Hex(), nil
}

// LastLogin is the resolver for the lastLogin field.
func (r *userResolver) LastLogin(ctx context.Context, obj *model.User) (*string, error) {
	if obj.LastLogin == nil {
		return nil, nil
	}

	return pointer.String(time.Unix(int64(obj.LastLogin.T), 0).Format(time.RFC3339)), nil
}

// LastActivity is the resolver for the last_activity field.
func (r *userResolver) LastActivity(ctx context.Context, obj *model.User) (*string, error) {
	if obj.LastActivity == nil {
		return nil, nil
	}

	return pointer.String(time.Unix(int64(obj.LastActivity.T), 0).Format(time.RFC3339)), nil
}

// Metadata is the resolver for the metadata field.
func (r *userResolver) Metadata(ctx context.Context, obj *model.User) (map[string]interface{}, error) {
	return obj.Metadata, nil
}

// Created is the resolver for the created field.
func (r *userResolver) Created(ctx context.Context, obj *model.User) (string, error) {
	return time.Unix(int64(obj.Created.T), 0).Format(time.RFC3339), nil
}

// Updated is the resolver for the updated field.
func (r *userResolver) Updated(ctx context.Context, obj *model.User) (string, error) {
	return time.Unix(int64(obj.Updated.T), 0).Format(time.RFC3339), nil
}

// Identities is the resolver for the identities field.
func (r *userResolver) Identities(ctx context.Context, obj *model.User) ([]*model.Identity, error) {
	var items []*model.Identity

	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	//find user by id
	cursor, err := r.db.Collection("identities").Find(ctx, bson.M{"uid": uid}, nil)
	if err != nil {
		return nil, err
	}

	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	if err = cursor.All(ctx, &items); err != nil {
		return nil, err
	}

	return items, nil
}

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }
