package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/dailytravel/x/account/auth"
	"github.com/dailytravel/x/account/graph/model"
	"github.com/dailytravel/x/account/utils"
	"github.com/go-redis/redis"
	jwt "github.com/golang-jwt/jwt/v4"
	"github.com/google/uuid"
	"github.com/typesense/typesense-go/typesense/api/pointer"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"golang.org/x/crypto/bcrypt"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	// Check if the user is authenticated
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	// Check if the email already exists
	existingUser := &model.User{}
	err = r.db.Collection(model.UserCollection).FindOne(ctx, bson.M{"email": input.Email}, nil).Decode(existingUser)
	if err == nil {
		return nil, fmt.Errorf("email already exists")
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	// Hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}

	// Create the new user
	newUser := &model.User{
		Name:     input.Name,
		Email:    input.Email,
		Password: string(hashedPassword),
		Model: model.Model{
			CreatedBy: uid,
			UpdatedBy: uid,
		},
	}

	for _, role := range input.Roles {
		newUser.Roles = append(newUser.Roles, *role)
	}

	// Insert the new user into the database
	res, err := r.db.Collection(newUser.Collection()).InsertOne(ctx, newUser, nil)
	if err != nil {
		return nil, err
	}

	newUser.ID = res.InsertedID.(primitive.ObjectID)

	return newUser, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.Payload, error) {
	var k *model.Key
	var a *model.Api
	var c *model.Client

	client := auth.APIKey(ctx)
	if client == nil {
		return nil, fmt.Errorf("client not found")
	}

	//check client
	if err := r.db.Collection("clients").FindOne(ctx, bson.M{"secret": client}, nil).Decode(&c); err != nil {
		return nil, fmt.Errorf("client not found")
	}

	//check api
	if err := r.db.Collection("apis").FindOne(ctx, bson.M{"identifier": "https://api.trip.express/graphql"}, nil).Decode(&a); err != nil {
		return nil, fmt.Errorf("api not found")
	}

	// Check if the user is already authenticated
	// authenticatedUser := auth.Auth(ctx)
	// if authenticatedUser != nil {
	// 	return nil, fmt.Errorf("user is already authenticated")
	// }

	// Check if the email already exists
	existingUser := &model.User{}
	err := r.db.Collection(model.UserCollection).FindOne(ctx, bson.M{"email": input.Email}, nil).Decode(existingUser)
	if err == nil {
		return nil, fmt.Errorf("email already exists")
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	// Hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}

	// Create the new user
	newUser := &model.User{
		Name:     input.Name,
		Email:    input.Email,
		Password: string(hashedPassword),
		Model: model.Model{
			CreatedBy: nil, // Set createdBy to nil for new registration
			UpdatedBy: nil,
		},
	}

	// Insert the new user into the database
	res, err := r.db.Collection(newUser.Collection()).InsertOne(ctx, newUser, nil)
	if err != nil {
		return nil, err
	}

	newUser.ID = res.InsertedID.(primitive.ObjectID)

	if err := r.db.Collection(k.Collection()).FindOne(ctx, bson.M{"status": "current"}, nil).Decode(&k); err != nil {
		return nil, fmt.Errorf("key not found")
	}

	access_token, err := auth.Token(jwt.MapClaims{
		"sub": newUser.ID.Hex(),
		"aud": a.Identifier,
		"iss": strings.Join([]string{"https://", c.Domain}, ""),
		"azp": c.ID.Hex(),
		"iat": time.Now().Unix(),
		"exp": time.Now().Add(time.Duration(time.Second * time.Duration(a.Expiration))).Unix(),
	}, k)

	if err != nil {
		return nil, err
	}

	refresh_token, err := auth.Token(jwt.MapClaims{
		"sub": newUser.ID.Hex(),
		"aud": a.Identifier,
		"iss": strings.Join([]string{"https://", c.Domain}, ""),
		"azp": c.ID.Hex(),
		"iat": time.Now().Unix(),
		"exp": time.Now().Add(time.Hour * 24 * 30).Unix(),
	}, k)

	if err != nil {
		return nil, err
	}

	return &model.Payload{
		AccessToken:  *access_token,
		RefreshToken: *refresh_token,
		TokenType:    "Bearer",
		ExpiresIn:    3600,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.Payload, error) {
	var u *model.User
	var k *model.Key
	var a *model.Api
	var c *model.Client

	client := auth.APIKey(ctx)
	if client == nil {
		return nil, fmt.Errorf("client not found")
	}

	//check client
	if err := r.db.Collection("clients").FindOne(ctx, bson.M{"secret": client}, nil).Decode(&c); err != nil {
		return nil, fmt.Errorf("client not found")
	}

	//check api
	if err := r.db.Collection("apis").FindOne(ctx, bson.M{"identifier": "https://api.trip.express/graphql"}, nil).Decode(&a); err != nil {
		return nil, fmt.Errorf("api not found")
	}

	//find user by email
	if err := r.db.Collection(model.UserCollection).FindOne(ctx, bson.M{"email": input.Email}, nil).Decode(&u); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	//check password
	if err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(input.Password)); err != nil {
		return nil, fmt.Errorf("password not match")
	}

	//get rsa key
	if err := r.db.Collection(model.KeyCollection).FindOne(ctx, bson.M{"status": "current"}, nil).Decode(&k); err != nil {
		return nil, fmt.Errorf("key not found")
	}

	// token, err := utils.Base64(32, false)
	// if err != nil {
	// 	return nil, err
	// }

	//create token
	t := &model.Token{
		UID:       u.ID,
		Name:      "auth",
		Token:     uuid.NewString(),
		Abilities: []*string{pointer.String("*")},
		ExpiresAt: &primitive.Timestamp{T: uint32(time.Now().Add(time.Duration(time.Second * time.Duration(a.Expiration))).Unix())},
	}

	//insert token
	if _, err := r.db.Collection(t.Collection()).InsertOne(ctx, t); err != nil {
		return nil, err
	}

	access_token, err := auth.Token(jwt.MapClaims{
		"jti": t.Token,
		"sub": u.ID.Hex(),
		"aud": a.Identifier,
		"iss": strings.Join([]string{"https://", c.Domain}, ""),
		"azp": c.ID.Hex(),
		"iat": time.Now().Unix(),
		"exp": t.ExpiresAt.T,
	}, k)

	if err != nil {
		return nil, err
	}

	refresh_token, err := auth.Token(jwt.MapClaims{
		"jti": t.Token,
		"sub": u.ID.Hex(),
		"aud": a.Identifier,
		"iss": strings.Join([]string{"https://", c.Domain}, ""),
		"azp": c.ID.Hex(),
		"iat": time.Now().Unix(),
		"exp": time.Now().Add(time.Hour * 24 * 30).Unix(),
	}, k)

	if err != nil {
		return nil, err
	}

	return &model.Payload{
		AccessToken:  *access_token,
		RefreshToken: *refresh_token,
		TokenType:    "Bearer",
		ExpiresIn:    3600,
	}, nil
}

// SocialLogin is the resolver for the socialLogin field.
func (r *mutationResolver) SocialLogin(ctx context.Context, provider model.SocialProvider, accessToken string) (*model.Payload, error) {
	var u *model.User
	var k *model.Key
	var a *model.Api
	var c *model.Client

	client := auth.APIKey(ctx)
	if client == nil {
		return nil, fmt.Errorf("client not found")
	}

	//check client
	if err := r.db.Collection("clients").FindOne(ctx, bson.M{"secret": client}, nil).Decode(&c); err != nil {
		return nil, fmt.Errorf("client not found")
	}
	// verify token from provider by google oauth
	email, err := auth.GoogleLogin(ctx, accessToken)
	if err != nil {
		return nil, err
	}

	// Check if the user already exists in the system
	if err := r.db.Collection("users").FindOne(ctx, bson.M{"email": email}, nil).Decode(&u); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	//get rsa key
	if err := r.db.Collection("keys").FindOne(ctx, bson.M{"status": "current"}, nil).Decode(&k); err != nil {
		return nil, fmt.Errorf("key not found")
	}

	access_token, err := auth.Token(jwt.MapClaims{
		"sub": u.ID.Hex(),
		"aud": a.Identifier,
		"iss": strings.Join([]string{"https://", c.Domain}, ""),
		"azp": c.ID.Hex(),
		"iat": time.Now().Unix(),
		"exp": time.Now().Add(time.Duration(time.Second * time.Duration(a.Expiration))).Unix(),
	}, k)

	if err != nil {
		return nil, err
	}

	refresh_token, err := auth.Token(jwt.MapClaims{
		"sub": u.ID.Hex(),
		"aud": a.Identifier,
		"iss": strings.Join([]string{"https://", c.Domain}, ""),
		"azp": c.ID.Hex(),
		"iat": time.Now().Unix(),
		"exp": time.Now().Add(time.Hour * 24 * 30).Unix(),
	}, k)

	if err != nil {
		return nil, err
	}

	return &model.Payload{
		AccessToken:  *access_token,
		RefreshToken: *refresh_token,
		TokenType:    "Bearer",
		ExpiresIn:    3600,
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUser) (*model.User, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	filter := bson.M{"_id": _id}

	item := &model.User{
		Name:     *input.Name,
		Email:    *input.Email,
		Timezone: input.Timezone,
		Locale:   input.Locale,
		Picture:  input.Picture,
		Phone:    input.Phone,
		Status:   *input.Status,
		Model: model.Model{
			UpdatedBy: uid,
		},
	}

	for _, role := range input.Roles {
		item.Roles = append(item.Roles, *role)
	}

	if err := r.db.Collection(item.Collection()).FindOneAndUpdate(ctx, filter, bson.M{"$set": item}).Decode(item); err != nil {
		return nil, err
	}

	return item, nil
}

// UpdateAccount is the resolver for the updateAccount field.
func (r *mutationResolver) UpdateAccount(ctx context.Context, input model.UpdateUser) (*model.User, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	//find user by id
	var item *model.User
	if err := r.db.Collection(model.UserCollection).FindOne(ctx, bson.M{"_id": uid}, nil).Decode(&item); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	//update user
	if input.Name != nil {
		item.Name = *input.Name
	}

	if input.Email != nil {
		item.Email = *input.Email
	}

	if input.Timezone != nil {
		item.Timezone = input.Timezone
	}

	if input.Locale != nil {
		item.Locale = input.Locale
	}

	if input.Picture != nil {
		item.Picture = input.Picture
	}

	if input.Phone != nil {
		item.Phone = input.Phone
	}

	if input.Status != nil {
		item.Status = *input.Status
	}

	if input.Roles != nil {
		for _, role := range input.Roles {
			item.Roles = append(item.Roles, *role)
		}
	}

	if _, err := r.db.Collection("users").UpdateOne(ctx, bson.M{"_id": uid}, bson.M{"$set": item}); err != nil {
		return nil, err
	}

	return item, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (map[string]interface{}, error) {
	var item *model.User
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}
	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	// Find the appointment by _id and delete it
	if err := r.db.Collection(model.UserCollection).FindOneAndUpdate(ctx, bson.M{"_id": bson.M{"$eq": _id, "$ne": uid}, "roles": bson.M{"$nin": []string{"admin"}}}, bson.M{"$set": bson.M{"deleted_at": primitive.Timestamp{T: uint32(time.Now().Unix())}, "deleted_by": uid}}, nil).Decode(&item); err != nil {
		return nil, err
	}

	return map[string]interface{}{"status": "success"}, nil
}

// DeleteUsers is the resolver for the deleteUsers field.
func (r *mutationResolver) DeleteUsers(ctx context.Context, ids []string) (map[string]interface{}, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	objectIDs := make([]primitive.ObjectID, len(ids))
	for i, id := range ids {
		objectID, err := primitive.ObjectIDFromHex(id)
		if err != nil {
			return nil, err
		}
		objectIDs[i] = objectID
	}

	filter := bson.M{"_id": bson.M{"$in": objectIDs}}
	update := bson.M{
		"$set": bson.M{
			"deleted_at": primitive.Timestamp{T: uint32(time.Now().Unix())},
			"deleted_by": uid,
		},
	}

	// Update multiple users by filtering with their _ids
	result, err := r.db.Collection(model.UserCollection).UpdateMany(ctx, filter, update)
	if err != nil {
		return nil, err
	}

	return map[string]interface{}{"status": "success", "deletedCount": result.ModifiedCount}, nil
}

// DeleteAccount is the resolver for the deleteAccount field.
func (r *mutationResolver) DeleteAccount(ctx context.Context) (map[string]interface{}, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	update := bson.M{
		"$set": bson.M{
			"deleted_at": primitive.Timestamp{T: uint32(time.Now().Unix())},
			"deleted_by": uid,
		},
	}

	// Find the user by _id and mark it as deleted
	result, err := r.db.Collection(model.UserCollection).UpdateByID(ctx, uid, update)
	if err != nil {
		return nil, err
	}

	return map[string]interface{}{"status": "success", "deletedCount": result.ModifiedCount}, nil
}

// RestoreUser is the resolver for the restoreUser field.
func (r *mutationResolver) RestoreUser(ctx context.Context, id string) (map[string]interface{}, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	update := bson.M{
		"$set": bson.M{
			"updated_by": uid,
			"updated_at": primitive.Timestamp{T: uint32(time.Now().Unix())},
		},
		"$unset": bson.M{
			"deleted_at": "",
			"deleted_by": "",
		},
	}

	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	result, err := r.db.Collection(model.UserCollection).UpdateByID(ctx, _id, update)
	if err != nil {
		return nil, err
	}

	return map[string]interface{}{
		"status":        "success",
		"modifiedCount": result.ModifiedCount,
	}, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, email string) (map[string]interface{}, error) {
	// Find user by email
	var user model.User
	if err := r.db.Collection(model.UserCollection).FindOne(ctx, bson.M{"email": email}).Decode(&user); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to retrieve user: %s", err.Error())
	}

	// Generate a unique code for the user
	code, err := utils.Base64(32, false)
	if err != nil {
		return nil, fmt.Errorf("failed to generate code: %s", err.Error())
	}

	// Store the code in Redis for 24 hours
	err = r.redis.Set(ctx, code, user.ID.Hex(), time.Hour*24).Err()
	if err != nil {
		return nil, fmt.Errorf("failed to store code: %s", err.Error())
	}

	return map[string]interface{}{
		"code": code,
	}, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, token string, password string, passwordConfirmation string) (map[string]interface{}, error) {
	// Retrieve email from Redis
	email, err := r.redis.Get(ctx, token).Result()
	if err == redis.Nil {
		return nil, fmt.Errorf("invalid token")
	} else if err != nil {
		return nil, fmt.Errorf("failed to retrieve token from Redis: %s", err.Error())
	}

	// Hash password
	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %s", err.Error())
	}

	// Update user password
	result, err := r.db.Collection(model.UserCollection).UpdateOne(
		ctx,
		bson.M{"email": email},
		bson.M{"$set": bson.M{"password": hash}},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update user password: %s", err.Error())
	} else if result.ModifiedCount == 0 {
		return nil, fmt.Errorf("user not found")
	}

	// Delete token from Redis
	deleted, err := r.redis.Del(ctx, token).Result()
	if err != nil {
		return nil, fmt.Errorf("failed to delete token from Redis: %s", err.Error())
	} else if deleted == 0 {
		return nil, fmt.Errorf("invalid token")
	}

	return map[string]interface{}{
		"code": nil,
	}, nil
}

// UpdatePassword is the resolver for the updatePassword field.
func (r *mutationResolver) UpdatePassword(ctx context.Context, input model.PasswordInput) (*model.User, error) {
	var item *model.User

	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	if input.Password != input.PasswordConfirmation {
		return nil, fmt.Errorf("passwords do not match")
	}

	//find user by id
	if err := r.db.Collection(model.UserCollection).FindOne(ctx, bson.M{"_id": uid}, nil).Decode(&item); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	//check password
	if err := bcrypt.CompareHashAndPassword([]byte(item.Password), []byte(input.CurrentPassword)); err != nil {
		return nil, fmt.Errorf("password is incorrect")
	}

	//hash password
	hash, err := bcrypt.GenerateFromPassword([]byte(input.Password), 10)
	if err != nil {
		return nil, fmt.Errorf("password is incorrect")
	}

	//update password
	if _, err := r.db.Collection(model.UserCollection).UpdateOne(ctx, bson.M{"_id": uid}, bson.M{"$set": bson.M{"password": string(hash)}}); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	return item, nil
}

// Verify is the resolver for the verify field.
func (r *mutationResolver) Verify(ctx context.Context, token string) (map[string]interface{}, error) {
	// Define constants
	const (
		invalidTokenError = "invalid token"
		failedToRetrieve  = "failed to retrieve token from Redis: %s"
		failedToUpdate    = "failed to update user status: %s"
		userNotFound      = "user not found"
		failedToDelete    = "failed to delete token from Redis: %s"
	)

	// Retrieve email from Redis
	email, err := r.redis.Get(ctx, token).Result()
	if err == redis.Nil {
		return nil, fmt.Errorf(invalidTokenError)
	} else if err != nil {
		return nil, fmt.Errorf(failedToRetrieve, err.Error())
	}

	// Update user status
	result, err := r.db.Collection(model.UserCollection).UpdateOne(
		ctx,
		bson.M{"email": email},
		bson.M{"$set": bson.M{"status": "active"}},
	)
	if err != nil {
		return nil, fmt.Errorf(failedToUpdate, err.Error())
	}
	if result.ModifiedCount == 0 {
		return nil, fmt.Errorf(userNotFound)
	}

	// Delete token from Redis
	deleted, err := r.redis.Del(ctx, token).Result()
	if err != nil {
		return nil, fmt.Errorf(failedToDelete, err.Error())
	}
	if deleted == 0 {
		return nil, fmt.Errorf(invalidTokenError)
	}

	// Return success message
	return map[string]interface{}{
		"success": true,
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, args map[string]interface{}) (map[string]interface{}, error) {
	res, err := r.ts.Collection(model.UserCollection).Documents().Search(utils.Params(args))
	if err != nil {
		return nil, err
	}

	// Convert struct to map
	results, err := utils.StructToMap(res)
	if err != nil {
		return nil, err
	}

	return results, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	var item *model.User
	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	filter := bson.M{"_id": _id}
	options := options.FindOne().SetProjection(bson.M{"_id": 1, "name": 1, "email": 1, "photos": 1})

	if err := r.db.Collection(item.Collection()).FindOne(ctx, filter, options).Decode(&item); err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, fmt.Errorf("no document found for filter %v", filter)
		}
		return nil, err
	}

	return item, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	var item *model.User
	//find user by id
	if err := r.db.Collection(model.UserCollection).FindOne(ctx, bson.M{"_id": uid}, nil).Decode(&item); err != nil {
		return nil, fmt.Errorf("user not found")
	}

	return item, nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *model.User) (string, error) {
	return obj.ID.Hex(), nil
}

// CreatedAt is the resolver for the created_at field.
func (r *userResolver) CreatedAt(ctx context.Context, obj *model.User) (string, error) {
	return time.Unix(int64(obj.CreatedAt.T), 0).Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updated_at field.
func (r *userResolver) UpdatedAt(ctx context.Context, obj *model.User) (string, error) {
	return time.Unix(int64(obj.UpdatedAt.T), 0).Format(time.RFC3339), nil
}

// Metadata is the resolver for the metadata field.
func (r *userResolver) Metadata(ctx context.Context, obj *model.User) (map[string]interface{}, error) {
	return obj.Metadata, nil
}

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }
