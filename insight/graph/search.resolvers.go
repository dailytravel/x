package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"
	"time"

	"github.com/dailytravel/x/insight/graph/model"
	"github.com/dailytravel/x/insight/internal/utils"
	"github.com/typesense/typesense-go/typesense/api"
	"github.com/typesense/typesense-go/typesense/api/pointer"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// CreateSearch is the resolver for the createSearch field.
func (r *mutationResolver) CreateSearch(ctx context.Context, input model.SearchInput) (*model.Search, error) {
	uid, err := utils.UID(ctx)
	if err != nil {
		return nil, err
	}

	// Create new search
	search := &model.Search{
		UID:       uid,
		Keyword:   input.Keyword,
		ClientIP:  input.ClientIP,
		UserAgent: input.UserAgent,
	}

	// Insert search into database
	res, err := r.db.Collection(search.Collection()).InsertOne(ctx, search)
	if err != nil {
		return nil, err
	}

	// Get inserted search
	search.ID = res.InsertedID.(primitive.ObjectID)

	return search, nil
}

// DeleteSearch is the resolver for the deleteSearch field.
func (r *mutationResolver) DeleteSearch(ctx context.Context, id string) (*bool, error) {
	_id, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	res, err := r.db.Collection("searches").DeleteOne(ctx, bson.M{"_id": _id})
	if err != nil {
		return nil, fmt.Errorf("error deleting search: %v", err)
	}

	if res.DeletedCount == 0 {
		return nil, fmt.Errorf("search not found")
	}

	return pointer.True(), nil
}

// DeleteSearches is the resolver for the deleteSearches field.
func (r *mutationResolver) DeleteSearches(ctx context.Context, filter map[string]interface{}) (*bool, error) {
	res, err := r.db.Collection("searches").DeleteMany(ctx, utils.Filter(filter))
	if err != nil {
		return nil, fmt.Errorf("error deleting searches: %v", err)
	}

	if res.DeletedCount == 0 {
		return nil, fmt.Errorf("searches not found")
	}

	return pointer.True(), nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, args map[string]interface{}) (map[string]interface{}, error) {
	// Initialize searchParams and commonSearchParams
	searchParams := api.MultiSearchParams{}
	commonSearchParams := api.MultiSearchSearchesParameter{}

	// Process searches
	if searches, ok := args["searches"].([]interface{}); ok {
		for _, search := range searches {
			if search, ok := search.(map[string]interface{}); ok {
				commonSearchParams.Searches = append(commonSearchParams.Searches, api.MultiSearchCollectionParameters{
					Collection: search["collection"].(string),
				})
			}
		}
	}

	if q, ok := args["q"].(string); ok {
		searchParams.Q = &q
	}

	if query_by, ok := args["query_by"].(string); ok {
		searchParams.QueryBy = &query_by
	}

	if filter_by, ok := args["filter_by"].(string); ok {
		searchParams.FilterBy = &filter_by
	}

	if sort_by, ok := args["sort_by"].(string); ok {
		searchParams.SortBy = &sort_by
	}

	if page, ok := args["page"].(json.Number); ok {
		// Convert JSON number to int
		if pageInt, err := strconv.Atoi(page.String()); err == nil {
			searchParams.Page = &pageInt
		}
	}

	if per_page, ok := args["per_page"].(json.Number); ok {
		// Convert JSON number to int
		if perPageInt, err := strconv.Atoi(per_page.String()); err == nil {
			searchParams.PerPage = &perPageInt
		}
	}

	res, err := r.ts.MultiSearch.Perform(&searchParams, commonSearchParams)
	if err != nil {
		return nil, err
	}

	// Convert struct to map
	results, err := utils.StructToMap(res)
	if err != nil {
		return nil, err
	}

	return results, nil
}

// Searches is the resolver for the searches field.
func (r *queryResolver) Searches(ctx context.Context, stages map[string]interface{}) (*model.Searches, error) {
	pipeline := bson.A{}

	// Add additional stages to the pipeline
	for key, value := range stages {
		stage := bson.D{{Key: key, Value: value}}
		pipeline = append(pipeline, stage)
	}

	cursor, err := r.db.Collection("searches").Aggregate(ctx, pipeline)
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var items []*model.Search

	if err := cursor.All(ctx, &items); err != nil {
		return nil, err
	}

	return &model.Searches{
		Count: int(cursor.RemainingBatchLength()),
		Data:  items,
	}, nil
}

// ID is the resolver for the id field.
func (r *searchResolver) ID(ctx context.Context, obj *model.Search) (string, error) {
	return obj.ID.Hex(), nil
}

// UID is the resolver for the uid field.
func (r *searchResolver) UID(ctx context.Context, obj *model.Search) (string, error) {
	return obj.UID.Hex(), nil
}

// Metadata is the resolver for the metadata field.
func (r *searchResolver) Metadata(ctx context.Context, obj *model.Search) (map[string]interface{}, error) {
	return obj.Metadata, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *searchResolver) Timestamp(ctx context.Context, obj *model.Search) (string, error) {
	return time.Unix(int64(obj.Timestamp.T), 0).Format(time.RFC3339), nil
}

// Search returns SearchResolver implementation.
func (r *Resolver) Search() SearchResolver { return &searchResolver{r} }

type searchResolver struct{ *Resolver }
