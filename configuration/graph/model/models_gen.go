// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type Currencies struct {
	Data  []*Currency `json:"data,omitempty"`
	Count int         `json:"count"`
}

type Locales struct {
	Count int       `json:"count"`
	Data  []*Locale `json:"data,omitempty"`
}

type Location struct {
	Lat *float64 `json:"lat,omitempty"`
	Lng *float64 `json:"lng,omitempty"`
}

type LocationInput struct {
	Lat *float64 `json:"lat,omitempty"`
	Lng *float64 `json:"lng,omitempty"`
}

type NewCurrency struct {
	ID        *string                `json:"id,omitempty"`
	Locale    string                 `json:"locale"`
	Name      string                 `json:"name"`
	Code      string                 `json:"code"`
	Rate      float64                `json:"rate"`
	Symbol    string                 `json:"symbol"`
	Precision int                    `json:"precision"`
	Decimal   string                 `json:"decimal"`
	Thousand  string                 `json:"thousand"`
	Order     int                    `json:"order"`
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

type NewLocale struct {
	ID         *string                `json:"id,omitempty"`
	Name       string                 `json:"name"`
	Locale     string                 `json:"locale"`
	Code       string                 `json:"code"`
	Order      int                    `json:"order"`
	Rtl        bool                   `json:"rtl"`
	DateFormat string                 `json:"date_format"`
	TimeFormat string                 `json:"time_format"`
	WeekStart  int                    `json:"week_start"`
	Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

type NewLocation struct {
	Parent      *string                  `json:"parent,omitempty"`
	Locale      string                   `json:"locale"`
	Type        string                   `json:"type"`
	Name        string                   `json:"name"`
	Slug        string                   `json:"slug"`
	Description *string                  `json:"description,omitempty"`
	Location    *LocationInput           `json:"location,omitempty"`
	Images      []map[string]interface{} `json:"images,omitempty"`
	Status      *string                  `json:"status,omitempty"`
	Reviewable  *bool                    `json:"reviewable,omitempty"`
	Popular     *bool                    `json:"popular,omitempty"`
	Order       *int                     `json:"order,omitempty"`
	Metadata    map[string]interface{}   `json:"metadata,omitempty"`
}

type NewOption struct {
	Name string `json:"name"`
	Data string `json:"data"`
}

type NewTemplate struct {
	Locale   string                 `json:"locale"`
	Name     string                 `json:"name"`
	Subject  string                 `json:"subject"`
	Body     string                 `json:"body"`
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	Status   *string                `json:"status,omitempty"`
}

type NewTimezone struct {
	Locale      string                 `json:"locale"`
	Name        string                 `json:"name"`
	Offset      int                    `json:"offset"`
	Description *string                `json:"description,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

type NewWebhook struct {
	Name    string                `json:"name"`
	URL     string                `json:"url"`
	Headers []*WebhookHeaderInput `json:"headers,omitempty"`
	Events  []*WebhookEventInput  `json:"events,omitempty"`
}

type Options struct {
	Data  []*Option `json:"data,omitempty"`
	Count int       `json:"count"`
}

type Places struct {
	Data  []*Place `json:"data,omitempty"`
	Count int      `json:"count"`
}

type Templates struct {
	Count int         `json:"count"`
	Data  []*Template `json:"data,omitempty"`
}

type Timezones struct {
	Count int         `json:"count"`
	Data  []*Timezone `json:"data,omitempty"`
}

type UpdateCurrency struct {
	Locale    *string                `json:"locale,omitempty"`
	Name      *string                `json:"name,omitempty"`
	Code      *string                `json:"code,omitempty"`
	Rate      *float64               `json:"rate,omitempty"`
	Symbol    *string                `json:"symbol,omitempty"`
	Precision *int                   `json:"precision,omitempty"`
	Decimal   *string                `json:"decimal,omitempty"`
	Thousand  *string                `json:"thousand,omitempty"`
	Order     *int                   `json:"order,omitempty"`
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
	Status    *string                `json:"status,omitempty"`
}

type UpdateLocale struct {
	Name       *string                `json:"name,omitempty"`
	Locale     string                 `json:"locale"`
	Code       *string                `json:"code,omitempty"`
	Order      *int                   `json:"order,omitempty"`
	Rtl        *bool                  `json:"rtl,omitempty"`
	DateFormat *string                `json:"date_format,omitempty"`
	TimeFormat *string                `json:"time_format,omitempty"`
	WeekStart  *int                   `json:"week_start,omitempty"`
	Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

type UpdateLocation struct {
	Parent      *string                  `json:"parent,omitempty"`
	Locale      *string                  `json:"locale,omitempty"`
	Type        *string                  `json:"type,omitempty"`
	Slug        *string                  `json:"slug,omitempty"`
	Name        *string                  `json:"name,omitempty"`
	Description *string                  `json:"description,omitempty"`
	Location    *LocationInput           `json:"location,omitempty"`
	Images      []map[string]interface{} `json:"images,omitempty"`
	Reviewable  *bool                    `json:"reviewable,omitempty"`
	Popular     *bool                    `json:"popular,omitempty"`
	Status      *string                  `json:"status,omitempty"`
	Metadata    map[string]interface{}   `json:"metadata,omitempty"`
}

type UpdateOption struct {
	Name *string `json:"name,omitempty"`
	Data *string `json:"data,omitempty"`
}

type UpdateTemplate struct {
	Locale   *string                `json:"locale,omitempty"`
	Name     *string                `json:"name,omitempty"`
	Subject  *string                `json:"subject,omitempty"`
	Body     *string                `json:"body,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	Status   *string                `json:"status,omitempty"`
}

type UpdateTimezone struct {
	Locale      *string                `json:"locale,omitempty"`
	Name        *string                `json:"name,omitempty"`
	Offset      *int                   `json:"offset,omitempty"`
	Description *string                `json:"description,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

type UpdateWebhook struct {
	Name    *string               `json:"name,omitempty"`
	URL     *string               `json:"url,omitempty"`
	Headers []*WebhookHeaderInput `json:"headers,omitempty"`
	Events  []*WebhookEventInput  `json:"events,omitempty"`
}

type WebhookEvent struct {
	ObjectID   string                `json:"objectId"`
	ObjectType string                `json:"objectType"`
	Actions    []*WebhookEventAction `json:"actions,omitempty"`
}

type WebhookEventInput struct {
	ObjectID   string                `json:"objectId"`
	ObjectType string                `json:"objectType"`
	Actions    []*WebhookEventAction `json:"actions,omitempty"`
}

type WebhookHeader struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type WebhookHeaderInput struct {
	Key   string  `json:"key"`
	Value *string `json:"value,omitempty"`
}

type Webhooks struct {
	Data  []*Webhook `json:"data,omitempty"`
	Count int        `json:"count"`
}

type CurrencyStatus string

const (
	CurrencyStatusActive   CurrencyStatus = "ACTIVE"
	CurrencyStatusInactive CurrencyStatus = "INACTIVE"
)

var AllCurrencyStatus = []CurrencyStatus{
	CurrencyStatusActive,
	CurrencyStatusInactive,
}

func (e CurrencyStatus) IsValid() bool {
	switch e {
	case CurrencyStatusActive, CurrencyStatusInactive:
		return true
	}
	return false
}

func (e CurrencyStatus) String() string {
	return string(e)
}

func (e *CurrencyStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CurrencyStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CurrencyStatus", str)
	}
	return nil
}

func (e CurrencyStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PlaceStatus string

const (
	PlaceStatusActive   PlaceStatus = "ACTIVE"
	PlaceStatusInactive PlaceStatus = "INACTIVE"
)

var AllPlaceStatus = []PlaceStatus{
	PlaceStatusActive,
	PlaceStatusInactive,
}

func (e PlaceStatus) IsValid() bool {
	switch e {
	case PlaceStatusActive, PlaceStatusInactive:
		return true
	}
	return false
}

func (e PlaceStatus) String() string {
	return string(e)
}

func (e *PlaceStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlaceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PlaceStatus", str)
	}
	return nil
}

func (e PlaceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PlaceType string

const (
	PlaceTypeCountry  PlaceType = "COUNTRY"
	PlaceTypeState    PlaceType = "STATE"
	PlaceTypeCity     PlaceType = "CITY"
	PlaceTypeDistrict PlaceType = "DISTRICT"
	PlaceTypeStreet   PlaceType = "STREET"
)

var AllPlaceType = []PlaceType{
	PlaceTypeCountry,
	PlaceTypeState,
	PlaceTypeCity,
	PlaceTypeDistrict,
	PlaceTypeStreet,
}

func (e PlaceType) IsValid() bool {
	switch e {
	case PlaceTypeCountry, PlaceTypeState, PlaceTypeCity, PlaceTypeDistrict, PlaceTypeStreet:
		return true
	}
	return false
}

func (e PlaceType) String() string {
	return string(e)
}

func (e *PlaceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlaceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PlaceType", str)
	}
	return nil
}

func (e PlaceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WebhookEventAction string

const (
	WebhookEventActionCreate    WebhookEventAction = "CREATE"
	WebhookEventActionUpdate    WebhookEventAction = "UPDATE"
	WebhookEventActionDelete    WebhookEventAction = "DELETE"
	WebhookEventActionPublish   WebhookEventAction = "PUBLISH"
	WebhookEventActionUnpublish WebhookEventAction = "UNPUBLISH"
)

var AllWebhookEventAction = []WebhookEventAction{
	WebhookEventActionCreate,
	WebhookEventActionUpdate,
	WebhookEventActionDelete,
	WebhookEventActionPublish,
	WebhookEventActionUnpublish,
}

func (e WebhookEventAction) IsValid() bool {
	switch e {
	case WebhookEventActionCreate, WebhookEventActionUpdate, WebhookEventActionDelete, WebhookEventActionPublish, WebhookEventActionUnpublish:
		return true
	}
	return false
}

func (e WebhookEventAction) String() string {
	return string(e)
}

func (e *WebhookEventAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookEventAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookEventAction", str)
	}
	return nil
}

func (e WebhookEventAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
